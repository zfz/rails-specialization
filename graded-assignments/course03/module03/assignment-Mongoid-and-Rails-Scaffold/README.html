<h1 id="module-3-summative-assignment-mongoid-and-rails-scaffold">Module 3, Summative Assignment: Mongoid and Rails Scaffold</h1>
<p>This assignment will evaluate your ability to implement a data tier using Mongoid and integrate that into a Rails controller and view.</p>
<p>The overall goal of the assignment is to:</p>
<ul>
<li>Implement a model and custom type classes mapped to an existing set of document schemas</li>
<li>Implement relationships of differing cardinality, realization, and direction</li>
<li>Implement constraints and validations for the data tier</li>
<li>Implement queries</li>
<li>Implement Web access to the database tier using a MVC thru Rails scaffold</li>
</ul>
<p>The functional goal of the assignment is to:</p>
<ul>
<li>Implement a data tier for triathlon race results</li>
<li>Implement a web tier to register for races and view race results.</li>
</ul>
<p>This assignment requires you to build a functional application with Mongoid and, in doing so, may require some features used that were not officially part of the class lectures and earlier formative assignments. When that occurs, specific URL references into the online documentation, extra hints, and descriptions are added as supplemental guidance for the assignment step.</p>
<p>The length of the assignment is partially due to the many examples shown throughout each section and the desire to put together a complete and interesting problem. The core of the assignment is within the data tier and how to make the web tier easier to implement. Once you reach the web tier, much of the code will be provided so that you will have a chance to visualize your data and observe how the web tier interacts with your data model. The following two images are of races and race results, respectively, and depicts the data that our application must manage.</p>
<div class="figure">
<img src="docs/races.png" alt="Races" /><p class="caption">Races</p>
</div>
<div class="figure">
<img src="docs/race-results.png" alt="Race Results" /><p class="caption">Race Results</p>
</div>
<h2 id="functional-requirements">Functional Requirements</h2>
<ol style="list-style-type: decimal">
<li><p>Ingest a set of documents.</p>
<ul>
<li><code>db/races.json</code> - contains <code>Race</code> documents that represent a specific race to occur.</li>
<li><code>db/racers.json</code> - contains <code>Racer</code> documents that represent a specific racer that participates in zero (0) or more races.</li>
<li><code>db/results.json</code> - contains <code>Entrant</code> documents that represent a specific racer's registration in a race and their results.</li>
</ul>
<p><img src="docs/module3-summative-drawing.jpg" alt="Data Model" /> <a href="docs/module3-summative-drawing.jpg"><code>Data Model</code></a></p></li>
<li><p>Implement a data tier to process the existing data and manage new information. The data tier consists of the following custom and document types:</p>
<ul>
<li><p>Implement three (3) custom types that represent data without any specific identity.</p>
<ul>
<li><code>Point</code> - a geographic point for an address</li>
<li><code>Address</code> - descriptive information for where something is located</li>
<li><code>Placing</code> - a ranked order someone finishes in a race within a category</li>
</ul></li>
<li><p>Implement nine (9) model classes plus a base class that represent specific information in a triathlon race.</p>
<ul>
<li><code>Racer</code> - represents a single individual and reference to all race entries.</li>
<li><code>RacerInfo</code> - represents the racer identity required by races he/she enters. The master copy is embedded within <code>Racer</code>. A copy of this is embedded within his/her <code>Entrant</code>, which represents the entry within a race.</li>
<li><code>Entrant</code> - represents a single racer's registration in a race and their results, broken down by leg -- to include swim, bike, and run events in addition to the two transitions between the three events.</li>
<li><code>LegResult</code> - is a base class representing the event results within a race for a specific racer. A leg can represent a transition or actual sport events. Sub-classes are supplied to track unique information per event. All instances of this class and sub-types are contained within an embedded collection within <code>Entrant</code>. Instances of this class will also embed copies of the <code>Event</code> they are a result for.</li>
<li><code>SwimResult</code> - is a sub-class of <code>LegResult</code> that reports results specific to a swimming event.</li>
<li><code>BikeResult</code> - is a sub-class of <code>LegResult</code> that reports results specific to a bike event.</li>
<li><code>RunResult</code> - is a sub-class of <code>LegResult</code> that reports results specific to a running event.</li>
<li><code>Race</code> - represents the overall race with its events and entrant information.</li>
<li><code>RaceRef</code> - represents race-identifying information that is copied into each <code>Entrant</code>. This is built from <code>Entrant</code> attributes.</li>
<li><code>Event</code> - represents a specific event within a race. It has a name (e.g., &quot;Swim&quot;, &quot;Bike&quot;, or &quot;Run&quot;) and a distance.</li>
</ul></li>
</ul></li>
<li><p>Implement an interface facade for the data tier to make access to information easier and safer for clients like the web tier. This will include:</p>
<ul>
<li>building a flat view of nested document attributes without changing our nested document structure</li>
<li>implementing cross-model service methods to avoid complex code from being written in the controller and view classes</li>
</ul></li>
<li><p>Implement web page access to <code>Race</code> and <code>Racer</code> information and the nested resource <code>Entrant</code> that holds the registration and results associated with them.</p>
<ul>
<li><code>Racer</code>s
<ul>
<li>an index page of all <code>Racer</code>s</li>
<li>a show page of finishes in each <code>Race</code> (via <code>Entrant</code>)</li>
</ul></li>
<li><code>Race</code>s
<ul>
<li>an index page of all Race`s</li>
<li>a show page of results for each <code>Racer</code> (via <code>Entrant</code>)</li>
</ul></li>
</ul></li>
<li><p>Implement web page access to register for future races.</p>
<ul>
<li><code>Racer</code>s
<ul>
<li>an edit page where <code>Racer</code>s can register for upcoming <code>Race</code>s that have not yet registered for (i.e., create an <code>Entrant</code>)</li>
</ul></li>
</ul></li>
</ol>
<h2 id="getting-started">Getting Started</h2>
<ol style="list-style-type: decimal">
<li><p>Start your MongoDB server using <code>mongod</code>.</p></li>
<li><p>Create a new Rails application called <code>triresults</code>.</p>
<pre class="shell"><code>$ rails new triresults
$ cd triresults</code></pre></li>
<li><p>Setup your application for Mongoid.</p>
<ul>
<li><p>Add the <code>mongoid</code> gem to your Gemfile and run <code>bundle</code>.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">gem <span class="st">&#39;mongoid&#39;</span>, <span class="st">&#39;~&gt; 5.0.0&#39;</span></code></pre></li>
<li><p>Generate a <code>mongoid.yml</code> configuration file.</p>
<pre class="shell"><code>$ rails g mongoid:config        # Rails command to generate mongoid config

    create config/mongoid.yml   # Output response to the above command</code></pre></li>
<li><p>Add the generated <code>mongoid.yml</code> file to <code>config/application.rb</code></p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">module</span> <span class="dt">Triresults</span>
  <span class="kw">class</span> <span class="dt">Application</span> &lt; <span class="dt">Rails</span>::<span class="dt">Application</span>
    ...
    <span class="co"># bootstraps mongoid within applications -- like rails console</span>
    <span class="dt">Mongoid</span>.load!(<span class="st">&#39;./config/mongoid.yml&#39;</span>)
    ...
   <span class="kw">end</span>
<span class="kw">end</span></code></pre></li>
</ul></li>
<li><p>Use the <code>rails console</code> during your development to invoke your solutions for the data tier. Adding the optional <code>test</code> after the <code>rails console</code> command will open the console using the test database instead of your development database.<br />Remember to reload after making changes to your source code.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">$ rails c 
&gt; ...
&gt; reload!
&gt; ...</code></pre></li>
<li><p>Download and extract the starter set of boostrap files for this assignment.</p>
<pre class="shell"><code>student-start/
|-- Gemfile
|-- db
|   |-- races.json
|   |-- racers.json
|   `-- results.json
|-- lib
|   `-- tasks
|       `-- assignment.rake
|-- .rspec (an important hidden file)
`-- spec
    |-- ..._spec.rb
    |-- ..._spec.rb
    `-- data
          |-- races.json
          |-- racers.json
          `-- results.json</code></pre>
<ul>
<li><p>Overwrite your existing Gemfile with the Gemfile from the bootstrap fileset. They should be nearly identical, but this is done to make sure the gems and versions you use in your solution can be processed by the automated Grader when you submit. Any submission should be tested with this version of the file.</p>
<p><strong>NOTE</strong> the Gemfile includes a section added for testing.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">group <span class="st">:test</span> <span class="kw">do</span>
    gem <span class="st">&#39;rspec-rails&#39;</span>, <span class="st">&#39;~&gt; 3.0&#39;</span>
    gem <span class="st">&#39;mongoid-rspec&#39;</span>, <span class="st">&#39;3.0.0&#39;</span>
    gem <span class="st">&#39;capybara&#39;</span>
<span class="kw">end</span></code></pre>
<p>as well as a new definition for the following items:</p>
<ul>
<li><code>tzinfo-data</code> gem conditionally included on Windows platforms</li>
<li><code>mongoid</code> gem</li>
</ul>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># Windows does not include zoneinfo files, so bundle the tzinfo-data gem</span>
gem <span class="st">&#39;tzinfo-data&#39;</span>, platforms: [<span class="st">:mingw</span>, <span class="st">:mswin</span>, <span class="st">:x64_mingw</span>, <span class="st">:jruby</span>]
gem <span class="st">&#39;mongoid&#39;</span>, <span class="st">&#39;~&gt; 5.0.0&#39;</span></code></pre></li>
<li><p>Add the provided json data files to your <code>db/</code> directory.</p></li>
<li><p>Add the provided rake assignment task to the <code>lib/tasks</code> directory in your <code>triresults</code> application. This file contains the rake task used by the tests to initialize the database prior to running the tests that determine if you have completed the assignment.</p></li>
<li><p>Add the <code>spec/*.rb</code> files provided with the bootstrap fileset to a corresponding <code>spec/</code> directory within your <code>triresults</code> application. These files contain tests that will help determine whether you have completed the assignment. Furthermore, copy the <code>spec/data/*.json</code> files over to a corresponding <code>spec/data/</code> directory within <code>triresults</code> as well. These are internal data files that rspec will use to execute its tests. Lastly, be sure to also copy the hidden <code>.rspec</code>file in the root directory.</p></li>
</ul></li>
<li><p>Run the <code>bundle</code> command to make sure all gems are available.</p>
<pre class="shell"><code>$ bundle</code></pre></li>
<li><p>Ingest the sample data. This data will assist you as you build and test your solution. The data is time-sensitive, so repeat as necessary to continue to have upcoming races in the future.</p>
<pre class="shell"><code>$ rake assignment:setup_data

importing data...
races=144, racers=1000, results=2880
updating database: triresults_development
updating race dates to current by (N) years
updating birth years to current by (N) years
updating creation and update times to (today)</code></pre>
<p><strong>Note</strong> that the data ingested into the development database is not used for grading. The tests will generate new data in the test database. You can refresh your development database by repeating the above commands if you delete or insert data you wish to remove.</p></li>
<li><p>Run the rspec test(s) to receive feedback. <code>rspec</code> must be run from the root directory of your application. There are several test files provided for this assignment. Many of those files are designed to test your code at specific points as you proceed through the technical requirements of this assignment. Initially, majority of tests will (obviously) fail until you complete the requirements necessary for them to pass.</p>
<pre class="shell"><code>$ rspec 
...
(N) examples, (N) failures, (N) pending</code></pre>
<p>To focus test feedback on a specific step of the requirements, add the specific file (path included) with the tests along with &quot;-e rq##&quot; to the rspec command line to only evaluate a specific requirement. Pad all step numbers to two digits.</p>
<pre class="shell"><code>$ rspec spec/railscheck_spec.rb -e rq00
...
(N) examples, (N) failures, (N) pending</code></pre></li>
<li><p>Implement your solution to the technical requirements and use the rspec tests to help verify your completed solution.</p></li>
<li><p>Submit your Rails app solution for grading.</p></li>
</ol>
<h2 id="technical-requirements">Technical Requirements</h2>
<h3 id="implement-custom-types">Implement Custom Types</h3>
<p>In this section you must implement three custom types; <code>Point</code>, <code>Address</code>, and <code>Placing</code>.</p>
<div class="figure">
<img src="docs/rsz_custom_types.png" alt="Custom Types" /><p class="caption"><code>Custom Types</code></p>
</div>
<p><a href="docs/rsz_custom_types.png"><code>Custom Types</code></a></p>
<p>Custom types are groupings of fields that occur within a document that do not have on ID. There are no <code>rails g</code> templates for creating custom classes but store them in the <code>apps/models</code> directory in separate files that follow the <code>snake_case.rb</code> file naming conventions. For each of these custom types, you must:</p>
<ul>
<li><p>implement an instance method called <code>mongoize</code> that accepts no arguments and marshals the state of the instance into MongoDB format as a Ruby hash. <strong>Hint</strong>:</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> mongoize
  <span class="kw">return</span> { ... }
<span class="kw">end</span> </code></pre></li>
<li><p>implement a class method called <code>mongoize</code> that accepts a single argument of at least three (3) forms -- nil, class instance, and database hash -- and returns the state marshalled into MongoDB format as a Ruby hash (if appropriate). <strong>Hint</strong>:</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> <span class="dv">self</span>.mongoize object
  <span class="kw">case</span> object
  <span class="kw">when</span> <span class="dv">nil</span> <span class="kw">then</span> ...
  <span class="kw">when</span> <span class="dt">Hash</span> <span class="kw">then</span> ...
  <span class="kw">when</span> (<span class="dt">ModelClass</span>) <span class="kw">then</span> ...
  <span class="kw">end</span> 
<span class="kw">end</span> </code></pre></li>
<li><p>implement a class method called <code>demongoize</code> that accepts a single argument of at least three (3) forms -- nil, class instance, and database hash form -- and returns an instance of the class (if appropriate). <strong>Hint</strong>:</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> <span class="dv">self</span>.demongoize object
  <span class="kw">case</span> object
  <span class="kw">when</span> <span class="dv">nil</span> <span class="kw">then</span> ...
  <span class="kw">when</span> <span class="dt">Hash</span> <span class="kw">then</span> ...
  <span class="kw">when</span> (<span class="dt">ModelClass</span>) <span class="kw">then</span> ...
  <span class="kw">end</span> 
<span class="kw">end</span> </code></pre></li>
<li><p>implement a class method called <code>evolve</code> that functionally behaves the same as the <code>mongoize</code> class method.</p></li>
</ul>
<ol style="list-style-type: decimal">
<li><p>Implement a custom type called <code>Point</code> to handle processing the <code>GeoJSON Point</code> format within the ingested JSON data. This class must:</p>
<ul>
<li>provide read/write access to a <code>longitude</code> field</li>
<li>provide read/write access to a <code>latitude</code> field</li>
<li><p>produce a MongoDB format consistent with the following:</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">{<span class="st">:type=</span>&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">:coordinates=</span>&gt;[(longitude), (latitude)]}</code></pre></li>
<li><p>gracefully handle nil inputs, initializing internals to nil or returning nil where appropriate</p></li>
</ul>
<p>You can demonstrate your custom type using the rails console. The following demonstrates demarshalling the MongoDB hash format into an object instance that can report longitude and latitude values.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; point=<span class="dt">Point</span>.demongoize(<span class="st">:type=</span>&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">:coordinates=</span>&gt;[-<span class="fl">122.27</span>,<span class="fl">37.80</span>])
 =&gt; <span class="co">#&lt;Point:0x00000005696540 @longitude=-122.27, @latitude=37.8&gt; </span>
&gt; point.longitude
 =&gt; -<span class="fl">122.27</span> 
&gt; point.latitude
 =&gt; <span class="fl">37.8</span> </code></pre>
<p>The following demonstrates marshalling the object instance and hash back out as a MongoDB hash -- ready for storage.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; point.mongoize
 =&gt; {<span class="st">:type=</span>&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">:coordinates=</span>&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>]} 
&gt; <span class="dt">Point</span>.mongoize(point)
 =&gt; {<span class="st">:type=</span>&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">:coordinates=</span>&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>]} 
&gt; <span class="dt">Point</span>.mongoize(<span class="st">:type=</span>&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">:coordinates=</span>&gt;[-<span class="fl">122.27</span>,<span class="fl">37.80</span>])
 =&gt; {<span class="st">:type=</span>&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">:coordinates=</span>&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>]}</code></pre>
<p>The following is an example of being called with nil data. A nil is returned, but could have been an empty point. We will not be entering this information at the UI, so we do not need any automatic build behavior.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">Point</span>.demongoize(<span class="dv">nil</span>)
 =&gt; <span class="dv">nil</span> </code></pre>
<pre class="shell"><code>$ rspec spec/custom_types_spec.rb -e rq01</code></pre></li>
<li><p>Implement a custom type called <code>Address</code> to handle processing the address format within the ingested JSON data. This class must:</p>
<ul>
<li>provide read/write access to a <code>city</code> field of type String mapped to the document key of <code>city</code></li>
<li>provide read/write access to a <code>state</code> field of type String mapped to the document key of <code>state</code></li>
<li>provide read/write access to a <code>location</code> field of type <code>Point</code> mapped to the document key of <code>loc</code></li>
<li><p>produce a MongoDB format consistent with the following:</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">{<span class="st">:city=</span>&gt;<span class="st">&quot;(city)&quot;</span>, <span class="st">:state=</span>&gt;<span class="st">&quot;(state)&quot;</span>, <span class="st">:loc=</span>&gt;(point)}</code></pre></li>
<li><p>gracefully handle nil inputs, initializing internals to nil or returning nil where appropriate</p></li>
</ul>
<p><strong>Note</strong> that this custom class is embedding a second custom class. Each of its <code>mongoize</code> and <code>demongoize</code> calls must delegate the commands to the embedded class to complete that area of the document.</p>
<p>You can demonstrate your custom type using the rails console. The following demonstrates demarshalling the MongoDB hash format into an object instance that can report all document fields as attributes.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; address=<span class="dt">Address</span>.demongoize(<span class="st">:city=</span>&gt;<span class="st">&quot;Oakland&quot;</span>, <span class="st">:state=</span>&gt;<span class="st">&quot;CA&quot;</span>, 
     <span class="st">:loc=</span>&gt;{<span class="st">:type=</span>&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">:coordinates=</span>&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>]})
 =&gt; <span class="co">#&lt;Address:0x00000004be7c48 @city=&quot;Oakland&quot;, @state=&quot;CA&quot;, </span>
     <span class="ot">@location</span>=<span class="co">#&lt;Point:0x00000004be97a0 @longitude=-122.27, @latitude=37.8&gt;&gt; </span>
&gt; address.city
 =&gt; <span class="st">&quot;Oakland&quot;</span> 
&gt; address.state
 =&gt; <span class="st">&quot;CA&quot;</span> 
&gt; address.location.longitude
 =&gt; -<span class="fl">122.27</span> 
&gt; address.location.latitude
 =&gt; <span class="fl">37.8</span> </code></pre>
<p>The following demonstrates marshalling the object instance and hash back out as a MongoDB hash -- ready for storage.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; address.mongoize
 =&gt; {<span class="st">:city=</span>&gt;<span class="st">&quot;Oakland&quot;</span>, <span class="st">:state=</span>&gt;<span class="st">&quot;CA&quot;</span>, <span class="st">:loc=</span>&gt;{<span class="st">:type=</span>&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">:coordinates=</span>&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>]}} 
&gt; <span class="dt">Address</span>.mongoize(address)
 =&gt; {<span class="st">:city=</span>&gt;<span class="st">&quot;Oakland&quot;</span>, <span class="st">:state=</span>&gt;<span class="st">&quot;CA&quot;</span>, <span class="st">:loc=</span>&gt;{<span class="st">:type=</span>&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">:coordinates=</span>&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>]}} 
&gt; <span class="dt">Address</span>.mongoize(<span class="st">:city=</span>&gt;<span class="st">&quot;Oakland&quot;</span>, <span class="st">:state=</span>&gt;<span class="st">&quot;CA&quot;</span>, 
      <span class="st">:loc=</span>&gt;{<span class="st">:type=</span>&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">:coordinates=</span>&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>]})
 =&gt; {<span class="st">:city=</span>&gt;<span class="st">&quot;Oakland&quot;</span>, <span class="st">:state=</span>&gt;<span class="st">&quot;CA&quot;</span>, <span class="st">:loc=</span>&gt;{<span class="st">:type=</span>&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">:coordinates=</span>&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>]}} </code></pre>
<p>The following is an example of being called with nil data. A nil is returned.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">Address</span>.demongoize(<span class="dv">nil</span>)
 =&gt; <span class="dv">nil</span></code></pre>
<pre class="shell"><code>$ rspec spec/custom_types_spec.rb -e rq02</code></pre></li>
<li><p>Implement a custom type called <code>Placing</code> to handle processing the placing format within the ingested JSON data. This class must:</p>
<ul>
<li>provide read/write access to a <code>name</code> field of type String mapped to the document key of <code>name</code></li>
<li>provide read/write access to a <code>place</code> field of type Integer mapped to the document key of <code>place</code></li>
<li><p>produce a MongoDB format consistent with the following format:</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">{<span class="st">:name=</span>&gt;<span class="st">&quot;(category name)&quot;</span> <span class="st">:place=</span>&gt;<span class="st">&quot;(ordinal placing)&quot;</span>}</code></pre></li>
<li><p>gracefully handle nil inputs, initializing internals to nil or returning nil where appropriate</p></li>
</ul>
<p>You can demonstrate your custom type using the rails console. The following demonstrates demarshalling the MongoDB hash format into an object instance that can report all document fields as attributes.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; group_placing=<span class="dt">Placing</span>.demongoize(<span class="st">:name=</span>&gt;<span class="st">&quot;masters&quot;</span>, <span class="st">:place=</span>&gt;<span class="dv">3</span>)
 =&gt; <span class="co">#&lt;Placing:0x00000004e02910 @name=&quot;masters&quot;, @place=3&gt; </span>
&gt; group_placing.name
 =&gt; <span class="st">&quot;masters&quot;</span> 
&gt; group_placing.place
 =&gt; <span class="dv">3</span> </code></pre>
<p>The following demonstrates marshalling the object instance and hash back out as a MongoDB hash -- ready for storage.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; group_placing.mongoize
 =&gt; {<span class="st">:name=</span>&gt;<span class="st">&quot;masters&quot;</span>, <span class="st">:place=</span>&gt;<span class="dv">3</span>} 
&gt; <span class="dt">Placing</span>.mongoize(group_placing)
 =&gt; {<span class="st">:name=</span>&gt;<span class="st">&quot;masters&quot;</span>, <span class="st">:place=</span>&gt;<span class="dv">3</span>} 
&gt; <span class="dt">Placing</span>.mongoize(<span class="st">:name=</span>&gt;<span class="st">&quot;masters&quot;</span>, <span class="st">:place=</span>&gt;<span class="dv">3</span>)
 =&gt; {<span class="st">:name=</span>&gt;<span class="st">&quot;masters&quot;</span>, <span class="st">:place=</span>&gt;<span class="dv">3</span>} </code></pre>
<p>The following is an example of being called with nil data. A nil is returned.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">Placing</span>.demongoize <span class="dv">nil</span>
 =&gt; <span class="dv">nil</span> </code></pre>
<pre class="shell"><code>$ rspec spec/custom_types_spec.rb -e rq03</code></pre></li>
</ol>
<h3 id="implement-racers-collection">Implement <code>racers</code> Collection</h3>
<p>This section concentrates on implementing the core of the <code>racers</code> collection, which consists of two model classes: <code>Racer</code> and <code>RacerInfo</code>.</p>
<div class="figure">
<img src="docs/rsz_racers_collection.png" alt="Racer Collection" /><p class="caption">Racer Collection</p>
</div>
<p><a href="docs/rsz_racers_collection.png">Racer Collection</a></p>
<p><code>RacerInfo</code> holds the core <code>Racer</code> information used to register for races. <code>Racer</code> embeds the <code>RacerInfo</code> and will hold relationships and information that may not be appropriate to store in an entrant registration.</p>
<p><code>RacerInfo</code> makes use of the <code>Address</code> and <code>Point</code> custom types. (Recall that <code>Address</code> uses a <code>location</code> attribute of type <code>Point</code>) <code>RacerInfo</code> must be implemented as an embedded class in such a way that it can be stored within <code>Racer</code> (the &quot;master&quot; copy) and <code>Entrant</code> (for each race). Relationships involving not yet implemented classes (e.g., <code>Entrant</code>) will be added later.</p>
<ol style="list-style-type: decimal">
<li><p>Implement a Mongoid model class called <code>RacerInfo</code> (<strong>Hint</strong>: <code>rails g model</code>) to act as the core information to identify the racer and to register for races.</p>
<ul>
<li>have a field called <code>first_name</code> of type String and mapped to the document key of <code>fn</code></li>
<li>have a field called <code>last_name</code> of type String and mapped to the document key of <code>ln</code></li>
<li>have a field called <code>gender</code> of type String and mapped to the document key of <code>g</code></li>
<li>have a field called <code>birth_year</code> of type Integer and mapped to the document key of <code>yr</code></li>
<li>have a field called <code>residence</code> of custom type <code>Address</code> and mapped to the document key <code>res</code></li>
<li><p>declare its <code>_id</code> field to be mapped to the document key <code>racer_id</code> and have its default value set to the value of <code>racer_id</code>. Declare the field as untyped so that whatever <code>_id</code> type is in the <code>Racer</code> can be stored in this field. The intent here is to have the id field stored in the document as <code>racer_id</code> and not have a duplicate <code>_id</code>. We may succeed. We may fail, but give it a try. <strong>Hint</strong>: One mechanism to do this is the following:</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">  field <span class="st">:racer_id</span>, as: <span class="st">:_id</span>
  field <span class="st">:_id</span>, default:-&gt;{ racer_id }</code></pre></li>
</ul>
<p>You can demonstrate your model class using the rails console. The following example shows a <code>RacerInfo</code> being built (but not saved) with all attributes being set, including a nested set of custom type classes for <code>Address</code> and <code>Point</code>. <strong>Note</strong> that the instance supports both model attribute names and document keys. The document produced uses the document key values when saving.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; point=<span class="dt">Point</span>.demongoize(<span class="st">:type=</span>&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">:coordinates=</span>&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>])
&gt; address=<span class="dt">Address</span>.demongoize(<span class="st">:city=</span>&gt;<span class="st">&quot;Oakland&quot;</span>, <span class="st">:state=</span>&gt;<span class="st">&quot;CA&quot;</span>, <span class="st">:loc=</span>&gt;point.mongoize)
&gt; <span class="dt">RacerInfo</span>.new(id:<span class="st">&quot;000&quot;</span>, fn:<span class="st">&quot;cat&quot;</span>, ln:<span class="st">&quot;inhat&quot;</span>, g:<span class="st">&quot;M&quot;</span>, yr:<span class="dv">1940</span>, res<span class="st">:address</span>)
<span class="dt">Overwriting</span> existing field _id <span class="kw">in</span> <span class="kw">class</span> <span class="dt">RacerInfo</span>.
 =&gt; <span class="co">#&lt;RacerInfo _id: 000, racer_id(_id): &quot;000&quot;, </span>
   fn(first_name): <span class="st">&quot;cat&quot;</span>, ln(last_name): <span class="st">&quot;inhat&quot;</span>, g(gender): <span class="st">&quot;M&quot;</span>, yr(birth_year): <span class="dv">1940</span>, 
   res(residence): {<span class="st">:city=</span>&gt;<span class="st">&quot;Oakland&quot;</span>, <span class="st">:state=</span>&gt;<span class="st">&quot;CA&quot;</span>, 
                    <span class="st">:loc=</span>&gt;{<span class="st">:type=</span>&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">:coordinates=</span>&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>]}}&gt; </code></pre>
<pre class="shell"><code>$ rspec spec/racers_spec.rb -e rq01</code></pre></li>
<li><p>Implement a Mongoid model class called <code>Racer</code> (<strong>Hint</strong>: <code>rails g model</code>) to act as the root-level document in the <code>racers</code> collection ingested in the initial section. This class must:</p>
<ul>
<li>(have no fields at this point)</li>
</ul>
<p>You can demonstrate your new model class using the rails console. The following just shows the hollow class we have at this point.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">Racer</span>.new.attributes
 =&gt; {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;568061efe301d07bcf000001&#39;</span>)}</code></pre>
<pre class="shell"><code>$ rspec spec/racers_spec.rb -e rq02</code></pre></li>
<li><p>Implement the polymorphic, 1:1 embedded relationship between <code>Racer</code> and <code>RacerInfo</code>. This is made to be polymorphic so that clones of <code>RacerInfo</code> can be can be embedded in both the <code>Racer</code> and <code>Entrant</code> model classes. In the <code>RacerInfo</code> class, you must:</p>
<ul>
<li>name the <code>embedded_in</code> relationship <code>parent</code></li>
<li>define the <code>embedded_in</code> relationship as polymorphic</li>
</ul>
<p>In the <code>Racer</code> class, you must:</p>
<ul>
<li>name the <code>embeds_one</code> relationship <code>info</code> (<strong>Hint</strong>: You will need to define a <code>class_name</code> mapping since <code>info</code> and <code>RacerInfo</code> are not consistent with one another)</li>
<li>define the <code>embeds_one</code> relationship as <code>autobuild: true</code> to automatically create the object when the relationship is navigated.</li>
<li>define the <code>embeds_one</code> relationship polymorphic type as <code>parent</code></li>
<li>implement a <code>before_create</code> callback to assign the local <code>id</code> primary key to the <code>info.id</code> property. <strong>Hint</strong>:</li>
</ul>
<pre class="sourceCode ruby"><code class="sourceCode ruby">before_create <span class="kw">do</span> |racer|
  racer.info.id = racer.id
<span class="kw">end</span></code></pre>
<p>You can demonstrate your new embedded relationship using the rails console. The following example shows the hollow <code>Racer</code> and <code>RacerInfo</code> being created and the <code>_id</code> of the <code>Racer</code> stored as <code>racer_id</code> in the <code>RacerInfo</code>. The <code>RacerInfo</code> object was created using the <code>autobuild</code> option during the <code>before_create</code> callback when the assignment was made.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; r=<span class="dt">Racer</span>.create
 =&gt; <span class="co">#&lt;Racer _id: 56806b4de301d07bcf00000c, &gt; </span>
&gt; <span class="dt">Racer</span>.collection.find(<span class="st">:_id=</span>&gt;r.id).first
 =&gt; {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56806b4de301d07bcf00000c&#39;</span>), 
     <span class="st">&quot;info&quot;</span>=&gt;{<span class="st">&quot;racer_id&quot;</span>=&gt;<span class="st">&quot;56806b4de301d07bcf00000c&quot;</span>}}</code></pre>
<p>The following demonstrates building an in-memory compound document for the <code>Racer</code> with <code>RacerInfo</code>, <code>Address</code>, and geolocation <code>Point</code> and then saving. The collection-level database query shows the embedded document and the assignment of <code>Racer</code>._id to <code>RacerInfo.racer_id</code>.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; point=<span class="dt">Point</span>.demongoize(<span class="st">:type=</span>&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">:coordinates=</span>&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>])
&gt; address=<span class="dt">Address</span>.demongoize(<span class="st">:city=</span>&gt;<span class="st">&quot;Oakland&quot;</span>, <span class="st">:state=</span>&gt;<span class="st">&quot;CA&quot;</span>, <span class="st">:loc=</span>&gt;point.mongoize)
&gt; racer=<span class="dt">Racer</span>.new
&gt; racer.build_info(fn:<span class="st">&quot;cat&quot;</span>, ln:<span class="st">&quot;inhat&quot;</span>, g:<span class="st">&quot;M&quot;</span>, yr:<span class="dv">1940</span>, res<span class="st">:address</span>)
<span class="dt">Overwriting</span> existing field _id <span class="kw">in</span> <span class="kw">class</span> <span class="dt">RacerInfo</span>.
&gt; racer.save
&gt; pp <span class="dt">Racer</span>.collection.find(<span class="st">:_id=</span>&gt;racer.id).first
{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;568070e3e301d07bcf000012&#39;</span>),
 <span class="st">&quot;info&quot;</span>=&gt;
  {<span class="st">&quot;fn&quot;</span>=&gt;<span class="st">&quot;cat&quot;</span>,
   <span class="st">&quot;ln&quot;</span>=&gt;<span class="st">&quot;inhat&quot;</span>,
   <span class="st">&quot;g&quot;</span>=&gt;<span class="st">&quot;M&quot;</span>,
   <span class="st">&quot;yr&quot;</span>=&gt;<span class="dv">1940</span>,
   <span class="st">&quot;res&quot;</span>=&gt;
    {<span class="st">&quot;city&quot;</span>=&gt;<span class="st">&quot;Oakland&quot;</span>,
     <span class="st">&quot;state&quot;</span>=&gt;<span class="st">&quot;CA&quot;</span>,
     <span class="st">&quot;loc&quot;</span>=&gt;{<span class="st">&quot;type&quot;</span>=&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">&quot;coordinates&quot;</span>=&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>]}},
   <span class="st">&quot;racer_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;568070e3e301d07bcf000012&#39;</span>)}}</code></pre>
<pre class="shell"><code>$ rspec spec/racers_spec.rb -e rq03</code></pre></li>
<li><p>Implement <a href="http://guides.rubyonrails.org/v3.2.13/active_record_validations_callbacks.html">field validation</a> for the <code>RacerInfo</code> that:</p>
<ul>
<li>validates <code>first_name</code> is present</li>
<li>validates <code>last_name</code> is present</li>
<li>validates <code>gender_name</code> is present and has values <code>M</code> or <code>F</code></li>
<li>validates <code>birth_year</code> is present and has value in the past</li>
</ul>
<p><strong>Hint</strong>: <code>:inclusion</code> and <code>:numericality</code></p>
<p>You can demonstrate your validations using the rails console. In this first example, we have provided no values for any of the fields. Note that our example shows some custom error text for <code>gender</code> having the wrong value and <code>birth_year</code> not being in the past. You are not required to provide any specific custom text in your validations.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; info=<span class="dt">RacerInfo</span>.new
&gt; info.validate
 =&gt; <span class="dv">false</span> 
&gt; pp info.errors.messages
{<span class="st">:first_name=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>],
 <span class="st">:last_name=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>],
 <span class="st">:gender=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>, <span class="st">&quot;must be M or F&quot;</span>],
 <span class="st">:birth_year=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>, <span class="st">&quot;must in past&quot;</span>]}</code></pre>
<p>In the next example, we supply invalid values for <code>gender</code> and <code>birth_year</code>. Notice we do not get errors for <code>gender</code> and <code>birth_year</code> not being supplied, but we do get errors for the invalid values they contain.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; info=<span class="dt">RacerInfo</span>.new(g:<span class="st">&quot;X&quot;</span>, yr:<span class="dv">2100</span>)
&gt; info.validate
 =&gt; <span class="dv">false</span> 
&gt; pp info.errors.messages
{<span class="st">:first_name=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>],
 <span class="st">:last_name=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>],
 <span class="st">:gender=</span>&gt;[<span class="st">&quot;must be M or F&quot;</span>],
 <span class="st">:birth_year=</span>&gt;[<span class="st">&quot;must in past&quot;</span>]}</code></pre>
<p>In the next example, we show how a <code>Racer</code> with no <code>RacerInfo</code> is valid but a <code>Racer</code> with an empty <code>RacerInfo</code> is not valid.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; racer=<span class="dt">Racer</span>.new
 =&gt; <span class="co">#&lt;Racer _id: 56807554e301d07bcf000017, &gt; </span>
&gt; racer.validate
 =&gt; <span class="dv">true</span> 
&gt; info=racer.info
 =&gt; <span class="co">#&lt;RacerInfo _id: , racer_id(_id): nil, fn(first_name): nil, ln(last_name): nil, </span>
    g(gender): <span class="dv">nil</span>, yr(birth_year): <span class="dv">nil</span>, res(residence): <span class="dv">nil</span>&gt; 
&gt; racer.validate
 =&gt; <span class="dv">false</span> 
&gt; racer.errors.messages
 =&gt; {<span class="st">:info=</span>&gt;[<span class="st">&quot;is invalid&quot;</span>]} </code></pre>
<p>In the last example, we supply valid values for all fields.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; info=<span class="dt">RacerInfo</span>.new(fn:<span class="st">&quot;cat&quot;</span>, ln:<span class="st">&quot;inhat&quot;</span>, g:<span class="st">&quot;M&quot;</span>, yr:<span class="dv">1940</span>)
&gt; info.validate
 =&gt; <span class="dv">true</span> 
&gt; pp info.errors.messages
{}</code></pre>
<pre class="shell"><code>$ rspec spec/racers_spec.rb -e rq04</code></pre></li>
</ol>
<h3 id="implement-races-collection">Implement <code>races</code> Collection</h3>
<p>This section concentrates on implementing the core of the <code>races</code> collection, which consists of <code>Race</code> and an embedded class <code>Event</code>.</p>
<div class="figure">
<img src="docs/rsz_races_collection.png" alt="Races Collection" /><p class="caption">Races Collection</p>
</div>
<p><a href="docs/rsz_races_collection.png">Races Collection</a></p>
<p>Relationships involving not yet implemented classes (e.g., <code>Entrant</code>) will be added later.</p>
<ol style="list-style-type: decimal">
<li><p>Implement a Mongoid model class called <code>Race</code> (<strong>Hint</strong>: <code>rails g model</code>) to act as the root-level document in the <code>races</code> collection ingested in the initial section. This class must:</p>
<ul>
<li>be defined to track timestamps using the <code>created_at</code> and <code>updated_at</code> document keys</li>
<li>have a field called <code>name</code> of type String and mapped to the document key of <code>n</code></li>
<li>have a field called <code>date</code> of type Date and mapped to the document key of <code>date</code></li>
<li>have a field called <code>location</code> of type Address and mapped to the document key of <code>loc</code></li>
</ul>
<p>You can demonstrate your new model class using the rails console. In this example we first build a transient instance and then save to the database. After that we use the create() option to automatically save the document to the database. Notice the <code>created_at</code> and <code>updated_at</code> timestamps in the database. These were automatically generated when the model was saved.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; point=<span class="dt">Point</span>.demongoize(<span class="st">:type=</span>&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">:coordinates=</span>&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>])
&gt; address=<span class="dt">Address</span>.demongoize(<span class="st">:city=</span>&gt;<span class="st">&quot;Oakland&quot;</span>, <span class="st">:state=</span>&gt;<span class="st">&quot;CA&quot;</span>, <span class="st">:loc=</span>&gt;point.mongoize)
&gt; race=<span class="dt">Race</span>.new(name:<span class="st">&quot;Oakland 10K&quot;</span>, date<span class="st">:Date</span>.current, location<span class="st">:address</span>)
&gt; race.save
&gt; race=<span class="dt">Race</span>.create(n:<span class="st">&quot;Oakland 10K&quot;</span>, date<span class="st">:Date</span>.current, loc<span class="st">:address</span>)
&gt; pp <span class="dt">Race</span>.find(race.id).attributes
{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;5677a506e301d0e5e2000018&#39;</span>),
 <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;Oakland 10K&quot;</span>,
 <span class="st">&quot;date&quot;</span>=&gt;<span class="dv">2015-12-21</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>,
 <span class="st">&quot;loc&quot;</span>=&gt;
  {<span class="st">&quot;city&quot;</span>=&gt;<span class="st">&quot;Oakland&quot;</span>,
   <span class="st">&quot;state&quot;</span>=&gt;<span class="st">&quot;CA&quot;</span>,
   <span class="st">&quot;loc&quot;</span>=&gt;{<span class="st">&quot;type&quot;</span>=&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">&quot;coordinates&quot;</span>=&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>]}},
 <span class="st">&quot;updated_at&quot;</span>=&gt;<span class="dv">2015-12-21</span> <span class="bn">07</span>:<span class="bn">06</span>:<span class="dv">46</span> <span class="dt">UTC</span>,
 <span class="st">&quot;created_at&quot;</span>=&gt;<span class="dv">2015-12-21</span> <span class="bn">07</span>:<span class="bn">06</span>:<span class="dv">46</span> <span class="dt">UTC</span>}</code></pre>
<pre class="shell"><code>$ rspec spec/races_spec.rb -e rq01</code></pre></li>
<li><p>Implement a Mongoid model class called <code>Event</code> (<strong>Hint</strong>: <code>rails g model</code>) to be embedded within <code>Race</code> and <code>LegResult</code> model classes using a polymorhic <code>embedded_in</code> relationship. This class must</p>
<ul>
<li>have a field called <code>order</code> of type Integer and mapped to the document key of <code>o</code></li>
<li>have a field called <code>name</code> of type String and mapped to the document key of <code>n</code></li>
<li>have a field called <code>distance</code> of type float and mapped to the document key of <code>d</code></li>
<li>have a field called <code>units</code> of type String and mapped to the document key of <code>u</code></li>
<li>have an instance method called <code>meters</code> that will return the length of the course in meters</li>
<li>have an instance method called <code>miles</code> that will return the length of the course in miles</li>
</ul>
<p><strong>Hint</strong>: There are</p>
<ul>
<li>1 meter = 0.000621371 miles</li>
<li>1 kilometer = 0.621371 miles</li>
<li>1 yard = 0.000568182 miles</li>
<li>1 yard = 0.9144 meters</li>
<li>1 mile = 1609.34 meters</li>
</ul>
<p>You can demonstrate the new model class using the rails console. In this example we are creating a default instance of the class and the built-in debug for a class instance shows the field names we have and their mappings to the document.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">Event</span>.new
 =&gt; <span class="co">#&lt;Event _id: 5677a72ce301d0e5e2000019, </span>
   o(order): <span class="dv">nil</span>, n(name): <span class="dv">nil</span>, d(distance): <span class="dv">nil</span>, u(units): <span class="dv">nil</span>&gt;</code></pre>
<p>In the next example, we demonstrate the conversion from miles to meters, meters to meters, and error cases that return nil when there is missing information.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">Event</span>.new(d:<span class="fl">0.000621371</span>*<span class="dv">10</span>, u:<span class="st">&quot;miles&quot;</span>).meters
 =&gt; <span class="fl">9.999972051399999</span>
&gt; <span class="dt">Event</span>.new(d:<span class="dv">10</span>, u:<span class="st">&quot;meters&quot;</span>).meters
 =&gt; <span class="fl">10.0</span> 
&gt; <span class="dt">Event</span>.new(d:<span class="dv">10</span>).meters
 =&gt; <span class="dv">nil</span> 
&gt; <span class="dt">Event</span>.new(u:<span class="st">&quot;meters&quot;</span>).meters
 =&gt; <span class="dv">nil</span> </code></pre>
<p>In the following we are demonstrating the conversion from meters to miles.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">Event</span>.new(d:<span class="fl">1609.34</span>, u:<span class="st">&quot;meters&quot;</span>).miles
 =&gt; <span class="fl">0.99999720514</span> </code></pre>
<pre class="shell"><code>$ rspec spec/races_spec.rb -e rq02</code></pre></li>
<li><p>Implement the polymorphic, M:1 embedded relationship between <code>Event</code> and <code>Race</code>. In the <code>Event</code> class, you must:</p>
<ul>
<li>name the <code>embedded_in</code> relationship <code>parent</code></li>
<li>define the <code>embedded_in</code> relationship as polymorphic</li>
<li>define the <code>embedded_in</code> relationship such that the parent's timestamp is updated whenever the child document is changed. <strong>Hint</strong>:</li>
</ul>
<pre class="sourceCode ruby"><code class="sourceCode ruby">touch: <span class="dv">true</span></code></pre>
<p>In the <code>Race</code> class, you must:</p>
<ul>
<li>name the <code>embeds_many</code> relationship <code>events</code></li>
<li>define the <code>embeds_many</code> relationship polymorphic type as <code>parent</code></li>
<li>define the <code>embeds_many</code> with a default ASCENDING sort order based on the <code>order</code> field. <strong>Hint</strong>: This is not covered in the online documentation, but can be accomplished by adding the following array property to the relationship.</li>
</ul>
<pre class="sourceCode ruby"><code class="sourceCode ruby">order: [<span class="st">:order</span>.asc]</code></pre>
<p>You can demonstrate your embedded relationship using the rails console. In this example we build the five (5) stages of a triathlon to include the two transition segments. The events are saved within an array within the <code>Racer</code> instance.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race=<span class="dt">Race</span>.find_by(n:<span class="st">&quot;Oakland 10K&quot;</span>)
&gt; race.events.build(o:<span class="dv">0</span>, n:<span class="st">&quot;swim&quot;</span>, d:<span class="dv">1</span>, u:<span class="st">&quot;miles&quot;</span>) 
&gt; race.events.build(o:<span class="dv">1</span>, n:<span class="st">&quot;t1&quot;</span>)                   
&gt; race.events.build(o:<span class="dv">2</span>, n:<span class="st">&quot;bike&quot;</span>, d:<span class="dv">25</span>, u:<span class="st">&quot;miles&quot;</span>) 
&gt; race.events.build(o:<span class="dv">3</span>, n:<span class="st">&quot;t2&quot;</span>)
&gt; race.events.build(o:<span class="dv">4</span>, n:<span class="st">&quot;run&quot;</span>, d:<span class="dv">10</span>, u:<span class="st">&quot;kilometers&quot;</span>) 
&gt; race.save
&gt; pp <span class="dt">Race</span>.find(race.id).attributes
{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;5677a506e301d0e5e2000018&#39;</span>),
 <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;Oakland 10K&quot;</span>,
 <span class="st">&quot;date&quot;</span>=&gt;<span class="dv">2015-12-21</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>,
 <span class="st">&quot;loc&quot;</span>=&gt;
  {<span class="st">&quot;city&quot;</span>=&gt;<span class="st">&quot;Oakland&quot;</span>,
   <span class="st">&quot;state&quot;</span>=&gt;<span class="st">&quot;CA&quot;</span>,
   <span class="st">&quot;loc&quot;</span>=&gt;{<span class="st">&quot;type&quot;</span>=&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">&quot;coordinates&quot;</span>=&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>]}},
 <span class="st">&quot;updated_at&quot;</span>=&gt;<span class="dv">2015-12-21</span> <span class="bn">07</span>:<span class="dv">41</span>:<span class="dv">00</span> <span class="dt">UTC</span>,
 <span class="st">&quot;created_at&quot;</span>=&gt;<span class="dv">2015-12-21</span> <span class="bn">07</span>:<span class="bn">06</span>:<span class="dv">46</span> <span class="dt">UTC</span>,
 <span class="st">&quot;events&quot;</span>=&gt;
  [{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;5677acace301d0e5e2000025&#39;</span>),
    <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">0</span>,
    <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;swim&quot;</span>,
    <span class="st">&quot;d&quot;</span>=&gt;<span class="fl">1.0</span>,
    <span class="st">&quot;u&quot;</span>=&gt;<span class="st">&quot;miles&quot;</span>},
   {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;5677acb5e301d0e5e2000026&#39;</span>), <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">1</span>, <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;t1&quot;</span>},
   {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;5677accee301d0e5e2000027&#39;</span>),
    <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">2</span>,
    <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;bike&quot;</span>,
    <span class="st">&quot;d&quot;</span>=&gt;<span class="fl">25.0</span>,
    <span class="st">&quot;u&quot;</span>=&gt;<span class="st">&quot;miles&quot;</span>},
   {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;5677acdfe301d0e5e2000028&#39;</span>), <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">3</span>, <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;t2&quot;</span>},
   {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;5677acf2e301d0e5e200002a&#39;</span>),
    <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">4</span>,
    <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;run&quot;</span>,
    <span class="st">&quot;d&quot;</span>=&gt;<span class="fl">10.0</span>,
    <span class="st">&quot;u&quot;</span>=&gt;<span class="st">&quot;kilometers&quot;</span>}]}</code></pre>
<p>In the next example, we change the sort order with a runtime expression.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race.events.order_by(<span class="st">:order</span>.desc).skip(<span class="dv">1</span>).limit(<span class="dv">3</span>).each {|r| p r}; <span class="dv">nil</span>
<span class="co">#&lt;Event _id: 5677acdfe301d0e5e2000028, o(order): 3, n(name): &quot;t2&quot;, d(distance): nil, u(units): nil&gt;</span>
<span class="co">#&lt;Event _id: 5677accee301d0e5e2000027, o(order): 2, n(name): &quot;bike&quot;, d(distance): 25.0, u(units): &quot;miles&quot;&gt;</span>
<span class="co">#&lt;Event _id: 5677acb5e301d0e5e2000026, o(order): 1, n(name): &quot;t1&quot;, d(distance): nil, u(units): nil&gt;</span></code></pre>
<p>In the next part of the example, we can test the navigation from the embedded class to the containing parent class thru the polymorphic <code>parent</code> reference in the embedded class.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race.events.first.parent.name
 =&gt; <span class="st">&quot;Oakland 10K&quot;</span></code></pre>
<pre class="shell"><code>$ rspec spec/races_spec.rb -e rq03</code></pre></li>
<li><p>Implement <code>field validation</code> for the <code>Event</code> that:</p>
<ul>
<li>validates <code>order</code> is present</li>
<li>validates <code>name</code> is present</li>
</ul>
<p>You can demonstrate your new validation using the rails console. In the following example, we show that an empty Event is not valid and reports specific error messages about the valid fields.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; event=<span class="dt">Event</span>.new
&gt; event.validate
 =&gt; <span class="dv">false</span> 
&gt; event.errors.messages
 =&gt; {<span class="st">:order=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>], <span class="st">:name=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>]}</code></pre>
<p>In the following example, we show that the <code>Race</code> is considered invalid if it has an invalid <code>Event</code>.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race=<span class="dt">Race</span>.new
&gt; event=race.events.build
&gt; race.validate
 =&gt; <span class="dv">false</span> 
&gt; race.errors.messages
 =&gt; {<span class="st">:events=</span>&gt;[<span class="st">&quot;is invalid&quot;</span>]} </code></pre>
<p>Notice that Mongoid refuses to save the <code>Race</code> in the invalid state.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race.save
 =&gt; <span class="dv">false</span> </code></pre>
<p>If we start by creating the <code>Race</code> in the database in a valid state, Mongoid refuses to change it to an invalid state by inserting an empty `Event.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race=<span class="dt">Race</span>.create
&gt; event=race.events.create
&gt; <span class="dt">Race</span>.where(<span class="st">:id=</span>&gt;race.id).first.attributes
 =&gt; {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56872a7fe301d0bcf8000016&#39;</span>), 
  <span class="st">&quot;updated_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01-02</span> <span class="bn">01</span>:<span class="dv">40</span>:<span class="dv">15</span> <span class="dt">UTC</span>, 
  <span class="st">&quot;created_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01-02</span> <span class="bn">01</span>:<span class="dv">40</span>:<span class="dv">15</span> <span class="dt">UTC</span>} </code></pre>
<p>If we instead insert a valid <code>Event</code>, the update is made to the <code>Race</code>. One unrelated but interesting thing to note is that Mongoid does not update the parent's <code>updated_at</code> timestamp by default, when modifying embedded children. The child relationship must define <code>touch: true</code> for that to occur.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; event=race.events.create(o:<span class="dv">0</span>,n:<span class="st">&quot;swim&quot;</span>)
&gt; pp <span class="dt">Race</span>.where(<span class="st">:id=</span>&gt;race.id).first.attributes
{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56872a7fe301d0bcf8000016&#39;</span>),
 <span class="st">&quot;updated_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01-02</span> <span class="bn">01</span>:<span class="dv">40</span>:<span class="dv">15</span> <span class="dt">UTC</span>,
 <span class="st">&quot;created_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01-02</span> <span class="bn">01</span>:<span class="dv">40</span>:<span class="dv">15</span> <span class="dt">UTC</span>,
 <span class="st">&quot;events&quot;</span>=&gt;
  [{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56872c5ee301d0bcf8000018&#39;</span>), <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">0</span>, <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;swim&quot;</span>}]}</code></pre>
<pre class="shell"><code>$ rspec spec/races_spec.rb -e rq04</code></pre></li>
<li><p>Implement a <a href="https://docs.mongodb.org/ecosystem/tutorial/mongoid-queries/#named-scopes"><code>named scope</code></a> in the <code>Race</code> class called by <code>upcoming</code> and <code>past</code> that returns a chainable criteria for races that have not completed and have occured in the past. These scopes must:</p>
<ul>
<li>return a chainable Mongoid query criteria set to return matching <code>Races</code> based on the <code>:date</code> property</li>
<li><code>upcoming</code> races have dates greater than or equal to today's date</li>
<li><code>past</code> races have dates less than today's date</li>
</ul>
<p>You can use the Rails console to demonstrate you new named scopes. In the example, below, we create three (3) races in the past, present, and future.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">Race</span>.create(<span class="st">:name=</span>&gt;<span class="st">&quot;Yesterday&#39;s Challenge&quot;</span>,<span class="st">:date=</span>&gt;<span class="dt">Date</span>.yesterday)
&gt; <span class="dt">Race</span>.create(<span class="st">:name=</span>&gt;<span class="st">&quot;Today&#39;s Challenge&quot;</span>,<span class="st">:date=</span>&gt;<span class="dt">Date</span>.current)
&gt; <span class="dt">Race</span>.create(<span class="st">:name=</span>&gt;<span class="st">&quot;Tomorrow&#39;s Challenge&quot;</span>,<span class="st">:date=</span>&gt;<span class="dt">Date</span>.tomorrow)</code></pre>
<p>When we request the <code>past</code> scope, we get only the races that have occured prior to today. In the example, we have also showed criteria chaining where we combine a criteria about the name of the race with the criteria returned from the scope.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; pp <span class="dt">Race</span>.past.where(<span class="st">:name=</span>&gt;{<span class="st">:$regex=</span>&gt;<span class="st">&quot;Challenge&quot;</span>}).first.attributes
D | {<span class="st">&quot;find&quot;</span>=&gt;<span class="st">&quot;races&quot;</span>, <span class="st">&quot;filter&quot;</span>=&gt;{<span class="st">&quot;date&quot;</span>=&gt;{<span class="st">&quot;$lt&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-27</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>},
<span class="st">&quot;n&quot;</span>=&gt;{<span class="st">&quot;$regex&quot;</span>=&gt;<span class="st">&quot;Challenge&quot;</span>}}, <span class="st">&quot;limit&quot;</span>=&gt;-<span class="dv">1</span>}
{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;5698fd86e301d000ef00001b&#39;</span>),
 <span class="st">&quot;next_bib&quot;</span>=&gt;<span class="dv">0</span>,
 <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;Yesterday&#39;s Challenge&quot;</span>,
 <span class="st">&quot;date&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-14</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>,
 <span class="st">&quot;updated_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-15</span> <span class="dv">14</span>:<span class="dv">09</span>:<span class="dv">10</span> <span class="dt">UTC</span>,
 <span class="st">&quot;created_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-15</span> <span class="dv">14</span>:<span class="dv">09</span>:<span class="dv">10</span> <span class="dt">UTC</span>}</code></pre>
<p>In the example using <code>upcoming</code>, we add <code>pluck</code> to the chain so that we request only the attributes we need from the database and Mongoid adds a <code>projection</code> to the MongoDB query.</p>
<pre><code>&gt; pp Race.upcoming.where(:name=&gt;{:$regex=&gt;&quot;Challenge&quot;}).pluck(:name, :date)
D | {&quot;find&quot;=&gt;&quot;races&quot;, &quot;filter&quot;=&gt;{&quot;date&quot;=&gt;{&quot;$gte&quot;=&gt;2016-01-15 00:00:00 UTC}, 
     &quot;n&quot;=&gt;{:$regex=&gt;&quot;Challenge&quot;}}, &quot;projection&quot;=&gt;{&quot;n&quot;=&gt;1, &quot;date&quot;=&gt;1}}
[[&quot;Today&#39;s Challenge&quot;, 2016-01-15 00:00:00 UTC],
[&quot;Tomorrow&#39;s Challenge&quot;, 2016-01-16 00:00:00 UTC]]</code></pre>
<pre class="shell"><code>$ rspec spec/races_spec.rb -e rq05</code></pre></li>
</ol>
<h3 id="implement-results-collection">Implement <code>results</code> Collection</h3>
<p>This section concentrates on implementing the core of the <code>results</code> collection, which consists of <code>Entrant</code>, the embedded class <code>LegResult</code> and its sub-classes ...</p>
<div class="figure">
<img src="docs/rsz_results_collection.png" alt="Results Collection" /><p class="caption">Results Collection</p>
</div>
<p><a href="docs/rsz_results_collection.png">Results Collection</a></p>
<p>... as well as the embedded classes (<code>RacerInfo</code> and <code>Event</code>) from the other two collections. We will complete the relationships with the other collections in a follow-on section.</p>
<ol style="list-style-type: decimal">
<li><p>Implement a Mongoid model class called <code>Entrant</code> (<strong>Hint</strong>: <code>rails g model</code>) to act as the root-level document in the <code>results</code> collection ingested in the initial section. This class must:</p>
<ul>
<li>be defined to be stored in the <code>results</code> collection</li>
<li>be defined to track timestamps using the <code>created_at</code> and <code>updated_at</code> document keys</li>
<li>have a field called <code>bib</code> of type Integer and mapped to the document key of <code>bib</code></li>
<li>have a field called <code>secs</code> of type Float and mapped to the document key of <code>secs</code></li>
<li>have a field called <code>overall</code> of type Placing and mapped to the document key of <code>o</code></li>
<li>have a field called <code>gender</code> of type <code>Placing</code> and mapped to the document key of <code>gender</code></li>
<li>have a field called <code>group</code> of type <code>Placing</code> and mapped to the document key of <code>group</code></li>
</ul>
<p>You can demonstrate your new model class using the rails console. <strong>Note</strong> that because the collection and model class do no share a common base name, we must manually map the class to the <code>results</code> collection.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">Entrant</span>.collection.name
 =&gt; <span class="st">&quot;results&quot;</span></code></pre>
<p>In the example below we create an instance of the <code>Entrant</code>, filling in extra details with custom type <code>Placing</code> for <code>overall</code>, <code>gender</code>, and <code>group</code>. You can use whatever initializer to create <code>Placing</code>. We are only showing the use of the <code>demongoize</code> method since the initializer is not an assignment requirement but <code>demongoize</code> is a requirement.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; entrant=<span class="dt">Entrant</span>.new(<span class="st">:bib=</span>&gt;<span class="dv">0</span>,<span class="st">:secs=</span>&gt;<span class="fl">100.123</span>)
&gt; entrant.overall=<span class="dt">Placing</span>.demongoize(<span class="st">:place=</span>&gt;<span class="dv">10</span>)
&gt; entrant.gender=<span class="dt">Placing</span>.demongoize(<span class="st">:name=</span>&gt;<span class="st">&quot;M&quot;</span>, <span class="st">:place=</span>&gt;<span class="dv">8</span>)
&gt; entrant.group=<span class="dt">Placing</span>.demongoize(<span class="st">:name=</span>&gt;<span class="st">&quot;masters&quot;</span>, <span class="st">:place=</span>&gt;<span class="dv">5</span>)
&gt; entrant.save
&gt; pp <span class="dt">Entrant</span>.find(entrant.id).attributes
{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;5678cec8e301d0e5e2000031&#39;</span>),
 <span class="st">&quot;bib&quot;</span>=&gt;<span class="dv">0</span>,
 <span class="st">&quot;secs&quot;</span>=&gt;<span class="fl">100.123</span>,
 <span class="st">&quot;o&quot;</span>=&gt;{<span class="st">&quot;place&quot;</span>=&gt;<span class="dv">10</span>},
 <span class="st">&quot;gender&quot;</span>=&gt;{<span class="st">&quot;name&quot;</span>=&gt;<span class="st">&quot;M&quot;</span>, <span class="st">&quot;place&quot;</span>=&gt;<span class="dv">8</span>},
 <span class="st">&quot;group&quot;</span>=&gt;{<span class="st">&quot;name&quot;</span>=&gt;<span class="st">&quot;masters&quot;</span>, <span class="st">&quot;place&quot;</span>=&gt;<span class="dv">5</span>},
 <span class="st">&quot;updated_at&quot;</span>=&gt;<span class="dv">2015-12-22</span> <span class="bn">04</span>:<span class="dv">18</span>:<span class="dv">40</span> <span class="dt">UTC</span>,
 <span class="st">&quot;created_at&quot;</span>=&gt;<span class="dv">2015-12-22</span> <span class="bn">04</span>:<span class="dv">18</span>:<span class="dv">40</span> <span class="dt">UTC</span>}</code></pre>
<p>You can verify the <code>Placings</code> can be demarshaled into an instance by reading out specific properties of each.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">Entrant</span>.find(entrant.id).group.name
 =&gt; <span class="st">&quot;masters&quot;</span>
&gt; <span class="dt">Entrant</span>.find(entrant.id).gender.place
 =&gt; <span class="dv">8</span> </code></pre>
<pre class="shell"><code>$ rspec spec/results_spec.rb -e rq01</code></pre></li>
<li><p>Implement a Mongoid model class called <code>LegResult</code> (<strong>Hint</strong>: <code>rails g model</code>) to act as the base class for individual event leg results and the implementation class for the two transition results in between the three events. This class must:</p>
<ul>
<li>have a field called <code>secs</code> of type Float and mapped to the document key of <code>secs</code></li>
<li>have an empty callback method called <code>calc_ave</code>. This will be used by sub-classes to update their event-specific average(s) based on the details of the <code>event</code> and the time to complete in <code>secs</code></li>
<li>have an <code>after_initialize</code> <a href="https://docs.mongodb.org/ecosystem/tutorial/mongoid-callbacks/#document-callbacks">callback</a> method defined to invoke <code>calc_ave</code></li>
<li>override the <code>secs=</code> method such that it calls <code>calc_ave</code> to refresh average(s) calculated after it has manually updated <code>self[:secs]</code> with the provided value.</li>
</ul>
<p><strong>Hint</strong>:</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> calc_ave
  <span class="co">#subclasses will calc event-specific ave</span>
<span class="kw">end</span>
after_initialize <span class="kw">do</span> |doc|
  <span class="co">#...</span>
<span class="kw">end</span>
<span class="kw">def</span> secs= value
  <span class="co">#...</span>
<span class="kw">end</span></code></pre>
<p>You can demonstrate your new model class using the rails console. In the following example we are creating a default instance.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">LegResult</span>.new
 =&gt; <span class="co">#&lt;LegResult _id: 569da237e301d0fa6b00001d, secs: nil&gt; </span>
&gt; result=<span class="dt">LegResult</span>.new(<span class="st">:secs=</span>&gt;<span class="dv">60</span>)
 =&gt; <span class="co">#&lt;LegResult _id: 569da2a5e301d0fa6b00001f, secs: 60.0&gt; </span>
&gt; result.secs=<span class="dv">120</span>
&gt; result
 =&gt; <span class="co">#&lt;LegResult _id: 569da2a5e301d0fa6b00001f, secs: 120.0&gt; </span></code></pre>
<pre class="shell"><code>$ rspec spec/results_spec.rb -e rq02</code></pre></li>
<li><p>Implement the concrete, M:1 embedded relationship between <code>LegResult</code> and <code>Entrant</code>. In the <code>LegResult</code> class, you must:</p>
<ul>
<li>name the <code>embedded_in</code> relationship <code>entrant</code></li>
</ul>
<p>In the <code>Entrant</code> class, you must:</p>
<ul>
<li>name the <code>embeds_many</code> relationship <code>results</code></li>
<li>map the <code>embeds_many</code> relationship to the base class <code>LegResult</code> (<strong>Hint</strong>: because of the difference in names, you must map the <code>class_name</code> for the collection to the proper classname stored in the collection)</li>
</ul>
<p>You can demonstrate your new relationship using the rails console. In the following example, we create a new, in-memory, anonymous <code>Entrant</code> and associate one <code>LegResult</code>. The object tree is not yet saved because we need to add some additional properties in a follow-on step to make <code>LegResult</code> complete.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; entrant=<span class="dt">Entrant</span>.new
&gt; result=entrant.results.build(<span class="st">:secs=</span>&gt;<span class="fl">60.13</span>)
 =&gt; <span class="co">#&lt;LegResult _id: 569dcc5fe301d00846000013, secs: 60.13&gt; </span>
&gt; result=entrant.results.build(<span class="st">:secs=</span>&gt;<span class="dv">1600</span>)
 =&gt; <span class="co">#&lt;LegResult _id: 569dcc66e301d00846000014, secs: 1600.0&gt; </span>
&gt; entrant.results.count
 =&gt; <span class="dv">0</span> 
&gt; entrant.results.to_a.count
 =&gt; <span class="dv">2</span> 
&gt; entrant.results[<span class="dv">0</span>]
 =&gt; <span class="co">#&lt;LegResult _id: 569dcc5fe301d00846000013, secs: 60.13&gt;</span>
&gt; pp entrant.results
[<span class="co">#&lt;LegResult _id: 569dcc5fe301d00846000013, secs: 60.13&gt;, </span>
 <span class="co">#&lt;LegResult _id: 569dcc66e301d00846000014, secs: 1600.0&gt;]</span></code></pre>
<pre class="shell"><code>$ rspec spec/results_spec.rb -e rq03</code></pre></li>
<li><p>Implement the polymorphic, 1:1 relationship between <code>LegResult</code> and <code>Event</code>. In the <code>LegResult</code> class, you must:</p>
<ul>
<li>name the <code>embeds_one</code> relationship <code>event</code></li>
<li>define the <code>embeds_one</code> relationship polymorphic type as <code>parent</code></li>
<li>add validation to require <code>event</code> to be supplied. We need this because the event will supply a sort order required by <code>Entrant</code> in the next bullet.</li>
</ul>
<p>In the Entrant class, you must:</p>
<ul>
<li>declare a default order based on the <code>event.o</code> value now required to exist. <strong>Hint</strong>:</li>
</ul>
<pre class="sourceCode ruby"><code class="sourceCode ruby">order: [:<span class="st">&quot;event.o&quot;</span>.asc]</code></pre>
<p>You can demonstrate your new embedded relationship using the rails console. In the following example, we verify our validation of <code>event</code> is in place by building an <code>Entrant</code> with a <code>LegResult</code> and just timing information. The <code>entrant</code> and <code>result</code> are invalid and refuse to be saved.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; entrant=<span class="dt">Entrant</span>.new
&gt; result=entrant.results.build(<span class="st">:secs=</span>&gt;<span class="fl">60.13</span>)
&gt; entrant.save
 =&gt; <span class="dv">false</span> 
&gt; entrant.errors.messages
 =&gt; {<span class="st">:results=</span>&gt;[<span class="st">&quot;is invalid&quot;</span>]} 
&gt; result.errors.messages
 =&gt; {<span class="st">:event=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>]} </code></pre>
<p>We locate an upcoming <code>Race</code> that has events defined and obtained the <code>t1</code> transition event. The attributes of this event are cloned into the <code>LegResult.event</code>, the <code>LegResult</code> and <code>Entrant</code> become valid and are successfully saved. <strong>Note</strong> in the evaluation of the <code>LegResult</code> it has an order and name.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race=<span class="dt">Race</span>.upcoming.where(:<span class="st">&quot;events.n&quot;</span>=&gt;<span class="st">&quot;t1&quot;</span>,:<span class="st">&quot;events.n&quot;</span>=&gt;<span class="st">&quot;t2&quot;</span>).first
&gt; event=race.events.where(<span class="st">:name=</span>&gt;<span class="st">&quot;t1&quot;</span>).first
&gt; result.build_event(event.attributes)
 =&gt; <span class="co">#&lt;Event _id: 569a58b8e301d083c300000e, o(order): 1, n(name): &quot;t1&quot;, d(distance): nil, u(units): nil&gt; </span>
&gt; entrant.validate
 =&gt; <span class="dv">true</span> 
&gt; entrant.save
 =&gt; <span class="dv">true</span> </code></pre>
<p>We repeat the process for a second result and show the resulting compound document that is stored in the database.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; event=race.events.where(<span class="st">:name=</span>&gt;<span class="st">&quot;t2&quot;</span>).first
&gt; entrant.results.create(<span class="st">:event=</span>&gt;event, <span class="st">:secs=</span>&gt;<span class="dv">45</span>)
&gt; pp <span class="dt">Entrant</span>.find(entrant.id).attributes
{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;569dd600e301d00846000021&#39;</span>),
 <span class="st">&quot;secs&quot;</span>=&gt;<span class="fl">105.13</span>,
 <span class="st">&quot;updated_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-19</span> <span class="bn">06</span>:<span class="dv">28</span>:<span class="dv">58</span> <span class="dt">UTC</span>,
 <span class="st">&quot;created_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-19</span> <span class="bn">06</span>:<span class="dv">22</span>:<span class="dv">26</span> <span class="dt">UTC</span>,
 <span class="st">&quot;results&quot;</span>=&gt;
  [{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;569dd605e301d00846000022&#39;</span>),
    <span class="st">&quot;_type&quot;</span>=&gt;<span class="st">&quot;LegResult&quot;</span>,
    <span class="st">&quot;secs&quot;</span>=&gt;<span class="fl">60.13</span>,
    <span class="st">&quot;event&quot;</span>=&gt;
     {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;569a58b8e301d083c300000e&#39;</span>), <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;t1&quot;</span>, <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">1</span>}},
   {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;569dd7aae301d00846000024&#39;</span>),
    <span class="st">&quot;_type&quot;</span>=&gt;<span class="st">&quot;LegResult&quot;</span>,
    <span class="st">&quot;secs&quot;</span>=&gt;<span class="fl">45.0</span>,
    <span class="st">&quot;event&quot;</span>=&gt;
     {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;569a58b8e301d083c3000010&#39;</span>), <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;t2&quot;</span>, <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">3</span>}}]}</code></pre>
<p><strong>Note</strong> that because we placed a default sort order on the embedded collection, the results come out in event order. We can change that order by supplying an <code>order_by</code> clause when we access the collection. <strong>Note</strong> the ascending and descending changes we are making in the output.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"> &gt; entrant.results.pluck(:<span class="st">&quot;event.o&quot;</span>)
 =&gt; [<span class="dv">1</span>, <span class="dv">3</span>] 
&gt; entrant.results.order_by(:<span class="st">&quot;event.o&quot;</span>.desc).pluck(:<span class="st">&quot;event.o&quot;</span>)
 =&gt; [<span class="dv">3</span>, <span class="dv">1</span>] 
&gt; entrant.results.order_by(:<span class="st">&quot;event.o&quot;</span>.asc).pluck(:<span class="st">&quot;event.o&quot;</span>)
 =&gt; [<span class="dv">1</span>, <span class="dv">3</span>] </code></pre>
<pre class="shell"><code>$ rspec spec/results_spec.rb -e rq04</code></pre></li>
<li><p>Implement the three (3) Mongoid model sub-classes of <code>LegResult</code>, called <code>SwimResult</code>, <code>BikeResult</code>, and <code>RunResult</code>. (<strong>Hint</strong>: <a href="https://docs.mongodb.org/ecosystem/tutorial/mongoid-documents/#inheritance"><code>Mongoid Inheritance</code></a>) These classes must:</p>
<ul>
<li>define <code>LegResult</code> as a base class</li>
<li>implement an instance method called <code>calc_ave</code> in each sub-class. Have it set the event-specific average(s) for each sub-class but have that be a dummy floating point number for now.</li>
<li><code>SwimResult</code> must have a field called <code>pace_100</code> of type Float and mapped to the document key of <code>pace_100</code>. This field represents the pace the swimmer would complete 100 meters, given the distance and time they take to complete the course.
<ul>
<li>assign this field a value within <code>calc_ave</code> instance method</li>
</ul></li>
<li><code>BikeResult</code> must have a field called <code>mph</code> of type Float and mapped to the document key of <code>mph</code>. This field represents the average speed the biker traveled over the course given the length of the course and the time they take to complete the course.
<ul>
<li>assign this field a value within <code>calc_ave</code> instance method</li>
</ul></li>
<li><code>RunResult</code> must have a field called <code>minute_mile</code> of type Float and mapped to the document key of <code>mmile</code>. This field represents the average time required to complete one (1) mile given the length and time to complete the course.
<ul>
<li>assign this field a value within <code>calc_ave</code> instance method</li>
</ul></li>
</ul>
<p><strong>Hint</strong>: calc_ave is being called by the base class after initialization and whenever the setter for <code>secs</code> is called. Each sub-class is responsible for updating their event-specific average(s). The example below shows that wiring with a bogus hard coded value for the conversion result (i.e., 12.1 stands for a real algorithm computed value)</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">  field my_ave, ...

  <span class="kw">def</span> calc_ave
    <span class="kw">if</span> event &amp;&amp; secs
      meters = event.meters
      <span class="dv">self</span>.my_ave=meters.nil? ? <span class="dv">nil</span> : <span class="fl">12.1</span>
    <span class="kw">end</span>
  <span class="kw">end</span></code></pre>
<p>You can demonstrate your new sub-classes (with dummy <code>calc</code> methods) using the rails console.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">SwimResult</span>.new(event<span class="st">:Event</span>.new(d:<span class="dv">100</span>,u:<span class="st">&quot;meters&quot;</span>),secs:<span class="dv">10</span>)
 =&gt; <span class="co">#&lt;SwimResult _id: 5687471fe301d0fd0300000f, secs: 10.0, _type: &quot;SwimResult&quot;, </span>
    pace_100: <span class="fl">12.1</span>&gt; 
&gt; <span class="dt">BikeResult</span>.new(event<span class="st">:Event</span>.new(d:<span class="dv">10</span>,u:<span class="st">&quot;miles&quot;</span>),secs:<span class="dv">3600</span>)
 =&gt; <span class="co">#&lt;BikeResult _id: 568747a3e301d0fd03000013, secs: 3600.0, _type: &quot;BikeResult&quot;, </span>
    mph: <span class="fl">12.1</span>&gt;
&gt; <span class="dt">RunResult</span>.new(event<span class="st">:Event</span>.new(d:<span class="dv">10</span>,u:<span class="st">&quot;miles&quot;</span>),secs:<span class="dv">3600</span>)
 =&gt; <span class="co">#&lt;RunResult _id: 568747ede301d0fd03000014, secs: 3600.0, _type: &quot;RunResult&quot;, </span>
    mmile(minute_mile): <span class="fl">12.1</span>&gt;</code></pre>
<pre class="shell"><code>$ rspec spec/results_spec.rb -e rq05</code></pre></li>
<li><p>Implement event-specific timing results in the <code>calc_ave</code> methods introduced in the previous step. Each <code>Event</code> will carry a <code>distance</code> and <code>units</code>. Units are either in <code>yards</code>, <code>meters</code>, <code>kilometers</code>, or <code>miles</code>. We have consolidated some conversion methods in <code>Event</code> as well -- which can report its distance in <code>miles</code> and <code>meters</code>. Each <code>LegResult</code> will have the time completed in seconds in the <code>secs</code> field. The <code>calc_ave</code> method in <code>SwimResult</code> must:</p>
<ul>
<li>calculate the secs it will take swimmer to travel 100 meters given the distance of the event and the time it took to complete. (<strong>Hint</strong>: <code>secs/(meters/100)</code>)</li>
</ul>
<p>The <code>calc_ave</code> method in the <code>BikeResult</code> must:</p>
<ul>
<li>calculate the average miles per hour given the distance of the event and the time it took to complete. (<strong>Hint</strong>: <code>miles*3600/secs</code>)</li>
</ul>
<p>The <code>calc_ave</code> method in the <code>RunResult</code> must:</p>
<ul>
<li>calculate the time it would take the runner to travel 1 mile given the distance of the event and the time it took to complete. (<strong>Hint</strong>: <code>(secs/60)/miles</code>)</li>
</ul>
<p><strong>Hint</strong>: There are</p>
<ul>
<li>1 minute = 60 secs</li>
<li>1 hour = 3600 secs</li>
</ul>
<p>You can test drive your new calculations using the rails console. The first example shows a 100 meter swim being finished in 10 secs for a 100 meter average of 10 secs. The second example shows a 1 mile swim being finished in 160.934 secs also for a 100 meter average of 10 secs.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">SwimResult</span>.new(<span class="st">:event=</span>&gt;<span class="dt">Event</span>.new(distance:<span class="dv">100</span>,units:<span class="st">&quot;meters&quot;</span>), <span class="st">:secs=</span>&gt;<span class="dv">10</span>)
 =&gt; <span class="co">#&lt;SwimResult _id: 5680bc02e301d07bcf00003f, secs: 10.0, _type: &quot;SwimResult&quot;, pace_100: 10.0&gt; </span>
&gt; <span class="dt">SwimResult</span>.new(<span class="st">:event=</span>&gt;<span class="dt">Event</span>.new(distance:<span class="dv">1</span>,units:<span class="st">&quot;miles&quot;</span>), <span class="st">:secs=</span>&gt;<span class="fl">160.934</span>)
 =&gt; <span class="co">#&lt;SwimResult _id: 5680bcb3e301d07bcf000041, secs: 160.934, _type: &quot;SwimResult&quot;, pace_100: 10.0&gt; </span></code></pre>
<p>The first example below shows a 10 mile bike being finished in 1 hour for a 10 mph average. The second example shows a 100K bike finished in 1 hour for a 62.137 mph average.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">BikeResult</span>.new(<span class="st">:event=</span>&gt;<span class="dt">Event</span>.new(distance:<span class="dv">10</span>,units:<span class="st">&quot;miles&quot;</span>), <span class="st">:secs=</span>&gt;<span class="dv">3600</span>)
 =&gt; <span class="co">#&lt;BikeResult _id: 5680be47e301d07bcf000046, secs: 3600.0, _type: &quot;BikeResult&quot;, mph: 10.0&gt; </span>
&gt; <span class="dt">BikeResult</span>.new(<span class="st">:event=</span>&gt;<span class="dt">Event</span>.new(distance:<span class="dv">100</span>,units:<span class="st">&quot;kilometers&quot;</span>), <span class="st">:secs=</span>&gt;<span class="dv">3600</span>)
 =&gt; <span class="co">#&lt;BikeResult _id: 5680bef4e301d07bcf000049, secs: 3600.0, _type: &quot;BikeResult&quot;, mph: 62.13710000000001&gt;</span></code></pre>
<p>The first example below shows a 1 mile run finished in 4 minutes for a 4 min/mile average. The second example shows a 10K run finished in 100min for a 16.09 min/mile average.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">RunResult</span>.new(<span class="st">:event=</span>&gt;<span class="dt">Event</span>.new(distance:<span class="dv">1</span>,units:<span class="st">&quot;miles&quot;</span>), <span class="st">:secs=</span>&gt;<span class="dv">240</span>)
 =&gt; <span class="co">#&lt;RunResult _id: 5680c0dbe301d07bcf00004f, secs: 240.0, _type: &quot;RunResult&quot;, </span>
    mmile(minute_mile): <span class="fl">4.0</span>&gt;
&gt; <span class="dt">RunResult</span>.new(<span class="st">:event=</span>&gt;<span class="dt">Event</span>.new(distance:<span class="dv">10</span>,units:<span class="st">&quot;kilometers&quot;</span>), <span class="st">:secs=</span>&gt;<span class="dv">6000</span>)
 =&gt; <span class="co">#&lt;RunResult _id: 5680c14de301d07bcf000052, secs: 6000.0, _type: &quot;RunResult&quot;, </span>
    mmile(minute_mile): <span class="fl">16.093444978925636</span>&gt; </code></pre>
<p>The following demonstrates updating the event-specific value of <code>secs</code>.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; s=<span class="dt">SwimResult</span>.new(event<span class="st">:Event</span>.new(d:<span class="dv">100</span>,u:<span class="st">&quot;meters&quot;</span>))
 =&gt; <span class="co">#&lt;SwimResult _id: 5688b95ee301d009f00000e7, secs: nil, _type: &quot;SwimResult&quot;, pace_100: nil&gt; </span>
 &gt; s.secs=<span class="dv">1000</span>
 &gt; s
 =&gt; <span class="co">#&lt;SwimResult _id: 5688b95ee301d009f00000e7, secs: 1000.0, _type: &quot;SwimResult&quot;, pace_100: 1000.0&gt;</span></code></pre>
<pre class="shell"><code>$ rspec spec/results_spec.rb -e rq06</code></pre></li>
<li><p>Implement a relationship callback in <code>Entrant</code> that will: (<strong>Hint</strong>: <a href="https://docs.mongodb.org/ecosystem/tutorial/mongoid-callbacks/#relation-callbacks"><code>Relation Callbacks</code></a>)</p>
<ul>
<li>set the value of <code>Entrant.secs</code> based on the sum of <code>event.secs</code>.</li>
</ul>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> update_total(result)
  <span class="dv">self</span>.secs=results...
<span class="kw">end</span></code></pre>
<p>You can demonstrate your callback logic using the rails console. In the following example, the <code>Entrant</code> is initially created with no <code>events</code> and has a <code>secs</code> value of <code>nil</code>. The <code>created_at</code> and <code>updated_at</code> are the same value and the state has not changed with what is in the database.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; entrant=<span class="dt">Entrant</span>.create                        
&gt; entrant.secs
 =&gt; <span class="dv">nil</span> 
&gt; entrant.created_at
 =&gt; <span class="dt">Sat</span>, <span class="dv">23</span> <span class="dt">Jan</span> <span class="dv">2016</span> <span class="dv">20</span>:<span class="dv">13</span>:<span class="dv">16</span> <span class="dt">UTC</span> +<span class="dv">00</span>:<span class="dv">00</span> 
&gt; entrant.updated_at
 =&gt; <span class="dt">Sat</span>, <span class="dv">23</span> <span class="dt">Jan</span> <span class="dv">2016</span> <span class="dv">20</span>:<span class="dv">13</span>:<span class="dv">16</span> <span class="dt">UTC</span> +<span class="dv">00</span>:<span class="dv">00</span> 
&gt; entrant.changed?
 =&gt; <span class="dv">false</span> </code></pre>
<p>If we add a new event, we see that Mongoid immediately stores the embedded document as an update to the parent document and our callback has &quot;changed&quot; the parent document by calling the setter on <code>secs</code> with a new value. However, the parent document state has not yet beed saved to the database so the <code>updated_at</code> is still unchanged.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; entrant.results &lt;&lt; <span class="dt">SwimResult</span>.new(
      <span class="st">:event=</span>&gt;<span class="dt">Event</span>.new(o:<span class="dv">0</span>,n:<span class="st">&quot;swim&quot;</span>,distance:<span class="dv">1</span>,units:<span class="st">&quot;miles&quot;</span>), <span class="st">:secs=</span>&gt;<span class="dv">3600</span>)
D | {<span class="st">&quot;update&quot;</span>=&gt;<span class="st">&quot;results&quot;</span>, <span class="st">&quot;updates&quot;</span>=&gt;[{<span class="st">&quot;q&quot;</span>=&gt;{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56a3dedce301d0a8d300000a&#39;</span>)}, 
                  <span class="st">&quot;u&quot;</span>=&gt;{<span class="st">&quot;$push&quot;</span>=&gt;{<span class="st">&quot;results&quot;</span>=&gt;{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56a3df1be301d0a8d300000b&#39;</span>), 
                  <span class="st">&quot;_type&quot;</span>=&gt;<span class="st">&quot;SwimResult&quot;</span>, <span class="st">&quot;secs&quot;</span>=&gt;<span class="fl">3600.0</span>, <span class="st">&quot;pace_100&quot;</span>=&gt;<span class="fl">223.69418519393045</span>, <span class="st">&quot;event&quot;</span>=...
&gt; entrant.changed?
 =&gt; <span class="dv">true</span> 
&gt; entrant.secs                   
 =&gt; <span class="fl">3600.0</span> 
&gt; entrant.updated_at
 =&gt; <span class="dt">Sat</span>, <span class="dv">23</span> <span class="dt">Jan</span> <span class="dv">2016</span> <span class="dv">20</span>:<span class="dv">13</span>:<span class="dv">16</span> <span class="dt">UTC</span> +<span class="dv">00</span>:<span class="dv">00</span> </code></pre>
<p>Once we call <code>save</code>, the update to <code>secs</code> and <code>updated_at</code> are written to the database. The instance will report it is no longer &quot;changed&quot; from the state in the database.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; entrant.save
D | {<span class="st">&quot;update&quot;</span>=&gt;<span class="st">&quot;results&quot;</span>, <span class="st">&quot;updates&quot;</span>=&gt;[{<span class="st">&quot;q&quot;</span>=&gt;{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56a3dedce301d0a8d300000a&#39;</span>)}, 
                  <span class="st">&quot;u&quot;</span>=&gt;{<span class="st">&quot;$set&quot;</span>=&gt;{<span class="st">&quot;secs&quot;</span>=&gt;<span class="fl">3600.0</span>, <span class="st">&quot;updated_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-23</span> <span class="dv">20</span>:<span class="dv">15</span>:<span class="bn">06</span> <span class="dt">UTC</span>}},...
&gt; entrant.changed?  
 =&gt; <span class="dv">false</span> 
&gt; entrant.updated_at
 =&gt; <span class="dt">Sat</span>, <span class="dv">23</span> <span class="dt">Jan</span> <span class="dv">2016</span> <span class="dv">20</span>:<span class="dv">15</span>:<span class="bn">06</span> <span class="dt">UTC</span> +<span class="dv">00</span>:<span class="dv">00</span> </code></pre>
<p>We can add additional events and have the <code>secs</code> recalculated with each change.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; entrant.results &lt;&lt; <span class="dt">BikeResult</span>.new(
      <span class="st">:event=</span>&gt;<span class="dt">Event</span>.new(o:<span class="dv">2</span>,n:<span class="st">&quot;bike&quot;</span>,distance:<span class="dv">100</span>,units:<span class="st">&quot;kilometers&quot;</span>), <span class="st">:secs=</span>&gt;<span class="dv">3600</span>)             
&gt; entrant.secs
 =&gt; <span class="fl">7200.0</span> 
&gt; entrant.results &lt;&lt; <span class="dt">RunResult</span>.new(
      <span class="st">:event=</span>&gt;<span class="dt">Event</span>.new(o:<span class="dv">4</span>,n:<span class="st">&quot;run&quot;</span>,distance:<span class="dv">10</span>,units:<span class="st">&quot;kilometers&quot;</span>), <span class="st">:secs=</span>&gt;<span class="dv">6000</span>)
&gt; entrant.secs
 =&gt; <span class="fl">13200.0</span> </code></pre>
<p>With all changes made to the <code>Entrant</code> we can now save the resultant time and get an <code>updated_at</code> change as well.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; entrant.changed?
 =&gt; <span class="dv">true</span> 
&gt; entrant.updated_at
 =&gt; <span class="dt">Sat</span>, <span class="dv">23</span> <span class="dt">Jan</span> <span class="dv">2016</span> <span class="dv">20</span>:<span class="dv">15</span>:<span class="bn">06</span> <span class="dt">UTC</span> +<span class="dv">00</span>:<span class="dv">00</span> 
&gt; entrant.save
&gt; entrant.updated_at
 =&gt; <span class="dt">Sat</span>, <span class="dv">23</span> <span class="dt">Jan</span> <span class="dv">2016</span> <span class="dv">20</span>:<span class="dv">16</span>:<span class="dv">40</span> <span class="dt">UTC</span> +<span class="dv">00</span>:<span class="dv">00</span> </code></pre>
<p>Out final compound document is as follows:</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; pp <span class="dt">Entrant</span>.find(entrant.id).attributes
{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56a3dedce301d0a8d300000a&#39;</span>),
 <span class="st">&quot;updated_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-23</span> <span class="dv">20</span>:<span class="dv">16</span>:<span class="dv">40</span> <span class="dt">UTC</span>,
 <span class="st">&quot;created_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-23</span> <span class="dv">20</span>:<span class="dv">13</span>:<span class="dv">16</span> <span class="dt">UTC</span>,
 <span class="st">&quot;results&quot;</span>=&gt;
  [{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56a3df1be301d0a8d300000b&#39;</span>),
    <span class="st">&quot;_type&quot;</span>=&gt;<span class="st">&quot;SwimResult&quot;</span>,
    <span class="st">&quot;secs&quot;</span>=&gt;<span class="fl">3600.0</span>,
    <span class="st">&quot;pace_100&quot;</span>=&gt;<span class="fl">223.69418519393045</span>,
    <span class="st">&quot;event&quot;</span>=&gt;
     {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56a3df1be301d0a8d300000c&#39;</span>),
      <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">0</span>,
      <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;swim&quot;</span>,
      <span class="st">&quot;d&quot;</span>=&gt;<span class="fl">1.0</span>,
      <span class="st">&quot;u&quot;</span>=&gt;<span class="st">&quot;miles&quot;</span>}},
   {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56a3df65e301d0a8d300000d&#39;</span>),
    <span class="st">&quot;_type&quot;</span>=&gt;<span class="st">&quot;BikeResult&quot;</span>,
    <span class="st">&quot;secs&quot;</span>=&gt;<span class="fl">3600.0</span>,
    <span class="st">&quot;mph&quot;</span>=&gt;<span class="fl">62.13710000000001</span>,
    <span class="st">&quot;event&quot;</span>=&gt;
     {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56a3df65e301d0a8d300000e&#39;</span>),
      <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">2</span>,
      <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;bike&quot;</span>,
      <span class="st">&quot;d&quot;</span>=&gt;<span class="fl">100.0</span>,
      <span class="st">&quot;u&quot;</span>=&gt;<span class="st">&quot;kilometers&quot;</span>}},
   {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56a3df8de301d0a8d300000f&#39;</span>),
    <span class="st">&quot;_type&quot;</span>=&gt;<span class="st">&quot;RunResult&quot;</span>,
    <span class="st">&quot;secs&quot;</span>=&gt;<span class="fl">6000.0</span>,
    <span class="st">&quot;mmile&quot;</span>=&gt;<span class="fl">16.093444978925636</span>,
    <span class="st">&quot;event&quot;</span>=&gt;
     {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56a3df8de301d0a8d3000010&#39;</span>),
      <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">4</span>,
      <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;run&quot;</span>,
      <span class="st">&quot;d&quot;</span>=&gt;<span class="fl">10.0</span>,
      <span class="st">&quot;u&quot;</span>=&gt;<span class="st">&quot;kilometers&quot;</span>}}],
 <span class="st">&quot;secs&quot;</span>=&gt;<span class="fl">13200.0</span>}</code></pre>
<pre class="shell"><code>$ rspec spec/results_spec.rb -e rq07</code></pre></li>
</ol>
<h3 id="implement-racesresults-cross-collection-relationships">Implement <code>races</code>/<code>results</code> Cross-Collection Relationships</h3>
<p>In the previous sections you implemented aspects of model classes that were local to a specific collection. In this section you will implement model class aspects that cross the boundary between the <code>races</code> and <code>results</code> collections.</p>
<div class="figure">
<img src="docs/rsz_races_results_cross_collection.png" alt="Races-Results Cross Collection" /><p class="caption">Races-Results Cross Collection</p>
</div>
<p><a href="docs/rsz_races_results_cross_collection.png"><code>Races-Results Cross Collection</code></a></p>
<ol style="list-style-type: decimal">
<li><p>Implement a Mongoid embedded model class called <code>RaceRef</code> (<strong>Hint</strong>: <code>rails g model</code>) to hold information about the <code>Race</code> that queries of an <code>Entrant</code> will need to immediately know about. This class must:</p>
<ul>
<li>have a field called <code>name</code> of type String and mapped to the document key of <code>n</code></li>
<li>have a field called <code>date</code> of type Date and mapped to the document key of <code>date</code></li>
</ul>
<p>You can demonstrate your new model class using the rails console. In the following example, we locate a <code>Race</code> and then initialize the <code>RaceRef</code> using the <code>Race</code> attributes that are trimmed down to just the elements that <code>RaceRef</code> uses. Notice the few example fields in <code>Race</code> (e.g., <code>created_at</code>) that were not involved in the initialization of <code>RacerRef</code>. The <code>symbolize_keys</code> function is being used to make sure that what we execute <code>slice</code> on uses symbols and not strings for keys.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race=<span class="dt">Race</span>.where(<span class="st">:name=</span>&gt;<span class="st">&quot;Oakland 10K&quot;</span>).first
 =&gt; <span class="co">#&lt;Race _id: 5677a506e301d0e5e2000018, </span>
   created_at: <span class="dv">2015-12-21</span> <span class="bn">07</span>:<span class="bn">06</span>:<span class="dv">46</span> <span class="dt">UTC</span>, updated_at: <span class="dv">2015-12-21</span> <span class="bn">07</span>:<span class="dv">41</span>:<span class="dv">00</span> <span class="dt">UTC</span>, 
   n(name): <span class="st">&quot;Oakland 10K&quot;</span>, date: <span class="dv">2015-12-21</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>, 
   loc(location): {<span class="st">&quot;city&quot;</span>=&gt;<span class="st">&quot;Oakland&quot;</span>, <span class="st">&quot;state&quot;</span>=&gt;<span class="st">&quot;CA&quot;</span>, ...


&gt; <span class="dt">RaceRef</span>.new(race.attributes.symbolize_keys.slice(<span class="st">:_id</span>,<span class="st">:n</span>,<span class="st">:date</span>))
 =&gt; <span class="co">#&lt;RaceRef _id: 5677a506e301d0e5e2000018, </span>
    n(name): <span class="st">&quot;Oakland 10K&quot;</span>, date: <span class="dv">2015-12-21</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>&gt;</code></pre>
<pre class="shell"><code>$ rspec spec/race_results_spec.rb -e rq01</code></pre></li>
<li><p>Implement the 1:1 embedded relationship between <code>Entrant</code> and <code>RaceRef</code>.</p>
<p>The <code>RaceRef</code> model class must:</p>
<ul>
<li>name the <code>embedded_in</code> relationship <code>entrant</code></li>
</ul>
<p>The <code>Entrant</code> model class must:</p>
<ul>
<li>name the <code>embeds_one</code> relationship <code>race</code></li>
<li>maps the <code>embeds_one</code> relationship to the <code>RaceRef</code> model class (otherwise it would incorrectly map to the <code>Race</code> model class)</li>
</ul>
<p>You can demonstrate your new relationship using the rails console. In the example below we instantiate a new <code>Entrant</code> and then within the block, build the <code>RaceRef</code> and <code>save</code> to the database. Notice how we now have the <code>_id</code> of the race as well as key information de-normalized into the <code>Entrant</code> compound document.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; entrant=<span class="dt">Entrant</span>.new {|r| \
    r.build_race(race.attributes.symbolize_keys.slice(<span class="st">:_id</span>,<span class="st">:n</span>,<span class="st">:date</span>)); r.save }
 =&gt; <span class="co">#&lt;Entrant _id: 56834b6ce301d07bcf0000b6, ...</span>
&gt; pp entrant.attributes
{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56834b6ce301d07bcf0000b6&#39;</span>),
 <span class="st">&quot;updated_at&quot;</span>=&gt;<span class="dv">2015-12-30</span> <span class="bn">03</span>:<span class="dv">11</span>:<span class="dv">40</span> <span class="dt">UTC</span>,
 <span class="st">&quot;created_at&quot;</span>=&gt;<span class="dv">2015-12-30</span> <span class="bn">03</span>:<span class="dv">11</span>:<span class="dv">40</span> <span class="dt">UTC</span>,
 <span class="st">&quot;race&quot;</span>=&gt;
  {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;5677a506e301d0e5e2000018&#39;</span>),
   <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;Oakland 10K&quot;</span>,
   <span class="st">&quot;date&quot;</span>=&gt;<span class="dv">2015-12-21</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>}}</code></pre>
<pre class="shell"><code>$ rspec spec/race_results_spec.rb -e rq02</code></pre></li>
<li><p>Implement the M:1 relationship between <code>Entrant</code>/<code>RaceRef</code> and <code>Race</code>. The foreign key will be in the <code>RaceRef</code> class embedded within <code>Entrant</code>. We will use that as part of a <code>belongs_to</code> definition for the M:1 relationship from <code>Entrant</code>/<code>RaceRef</code>. <code>Race</code> will leverage the embedded foreign key to implement the inverse side using a <code>belongs_to</code>. The <code>RaceRef</code> embedded model class must:</p>
<ul>
<li>name the <code>belongs_to</code> relationship <code>race</code></li>
<li>map the <code>belongs_to</code> relationship to the <code>_id</code> document foreign key field. (<strong>Hint</strong>: <code>foreign_key: &quot;_id&quot;</code>)</li>
</ul>
<p>The <code>Entrant</code> class must:</p>
<ul>
<li>define an accessor called <code>the_race</code> that returns the result of <code>race.race</code> -- where the first <code>race</code> references the embedded <code>RaceRef</code> and the second <code>race</code> references the <code>Race</code> document in the other collection.</li>
</ul>
<p>The <code>Race</code> class must:</p>
<ul>
<li>name the <code>has_many</code> relationship <code>entrants</code></li>
<li>map the <code>has_many</code> relationship to the foreign key <code>race._id</code> which references the <code>_id</code> document field property within the embedded <code>RaceRef</code> stored using the <code>race</code> field. (<strong>Hint</strong>: <code>foreign_key: &quot;race._id&quot;</code>)</li>
<li>define a dependent constraint on the relationship to delete child <code>Entrant</code>s when the <code>Race</code> is deleted.</li>
<li>define a default sort order using the <code>secs</code> ASCENDING and <code>bib</code> number ASCENDING. This will order the entrants by bib# until times are reported. (<strong>Hint</strong>: <code>order: [:secs.asc, :bib.asc]</code>)</li>
</ul>
<p>You can demonstrate your new relationship using the rails console. In the following example we create a new <code>Race</code> and two (2) <code>Entrant</code>s -- filling in the attributes of the <code>RaceRef</code> using the <code>Race</code> instance. Each <code>Entrant</code> was also assigned a unique <code>bib</code> number and a value for <code>secs</code> that we can search for and help identify the entrant.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race2=<span class="dt">Race</span>.create(<span class="st">:name=</span>&gt;<span class="st">&quot;Oakland 2K&quot;</span>, <span class="st">:date=</span>&gt;<span class="dt">Date</span>.current, <span class="st">:loc=</span>&gt;race.loc)               
&gt; entrant1=<span class="dt">Entrant</span>.new(<span class="st">:bib=</span>&gt;<span class="dv">1</span>, <span class="st">:secs=</span>&gt;<span class="fl">1100.23</span>) {|r| \
    r.build_race(race2.attributes.symbolize_keys.slice(<span class="st">:_id</span>,<span class="st">:n</span>,<span class="st">:date</span>)); r.save }                 
&gt; entrant2=<span class="dt">Entrant</span>.new(<span class="st">:bib=</span>&gt;<span class="dv">2</span>, <span class="st">:secs=</span>&gt;<span class="fl">1200.23</span>) {|r| \
    r.build_race(race2.attributes.symbolize_keys.slice(<span class="st">:_id</span>,<span class="st">:n</span>,<span class="st">:date</span>)); r.save }                               </code></pre>
<p>If we invoke the <code>race.name</code> method, we are requesting information from the local collection embedded within <code>Entrant.RaceRef</code>. If we invoke the <code>the_race.loc.city</code> method, we are accessing a document from the parent collection.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; entrant1.race.name
 =&gt; <span class="st">&quot;Oakland 2K&quot;</span> 
&gt; entrant2.the_race.loc.city
 =&gt; <span class="st">&quot;Oakland&quot;</span> </code></pre>
<p>We can issue queries from the parent collection to locate all child <code>Entrant</code>s or <code>Entrant</code>s matching a criteria. <strong>Note</strong> that query results for all <code>Entrant</code>s is ordered by the default order defined in the parent model class.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race2.entrants.pluck(<span class="st">:bib</span>)
D | {<span class="st">&quot;find&quot;</span>=&gt;<span class="st">&quot;results&quot;</span>, <span class="st">&quot;filter&quot;</span>=&gt;{<span class="st">&quot;race._id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56836dffe301d07bcf0000c7&#39;</span>)},
     <span class="st">&quot;projection&quot;</span>=&gt;{<span class="st">&quot;bib&quot;</span>=&gt;<span class="dv">1</span>}, <span class="st">&quot;sort&quot;</span>=&gt;{<span class="st">&quot;bib&quot;</span>=&gt;<span class="dv">1</span>}}
 =&gt; [<span class="dv">1</span>, <span class="dv">2</span>] 
&gt; race2.entrants.where(<span class="st">:bib=</span>&gt;<span class="dv">1</span>).first.secs
D | {<span class="st">&quot;find&quot;</span>=&gt;<span class="st">&quot;results&quot;</span>, <span class="st">&quot;filter&quot;</span>=&gt;{<span class="st">&quot;race._id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56836dffe301d07bcf0000c7&#39;</span>), 
     <span class="st">&quot;bib&quot;</span>=&gt;<span class="dv">1</span>}, <span class="st">&quot;sort&quot;</span>=&gt;{<span class="st">&quot;bib&quot;</span>=&gt;<span class="dv">1</span>}}
 =&gt; <span class="fl">1100.23</span> </code></pre>
<p>If we delete the parent <code>Race</code>, all child <code>Entrant</code> documents are also deleted.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race2.delete
D | {<span class="st">&quot;count&quot;</span>=&gt;<span class="st">&quot;results&quot;</span>, <span class="st">&quot;query&quot;</span>=&gt;{<span class="st">&quot;race._id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56836dffe301d07bcf0000c7&#39;</span>)}}
D | {<span class="st">&quot;delete&quot;</span>=&gt;<span class="st">&quot;results&quot;</span>, <span class="st">&quot;deletes&quot;</span>=&gt;[{<span class="st">&quot;q&quot;</span>=&gt;{<span class="st">&quot;race._id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56836dffe301d07bcf0000c7&#39;</span>)},...
D | {<span class="st">&quot;delete&quot;</span>=&gt;<span class="st">&quot;races&quot;</span>, <span class="st">&quot;deletes&quot;</span>=&gt;[{<span class="st">&quot;q&quot;</span>=&gt;{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56836dffe301d07bcf0000c7&#39;</span>)},...
 =&gt; <span class="dv">true</span> 

&gt; <span class="dt">Entrant</span>.in(<span class="st">:id=</span>&gt;[entrant1.id,entrant2.id]).exists?
D, | {<span class="st">&quot;find&quot;</span>=&gt;<span class="st">&quot;results&quot;</span>, <span class="st">&quot;filter&quot;</span>=&gt;{<span class="st">&quot;_id&quot;</span>=&gt;{
      <span class="st">&quot;$in&quot;</span>=&gt;[<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56836e17e301d07bcf0000c8&#39;</span>), <span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56a660f1e301d0f1ed000037&#39;</span>)]}}, 
      <span class="st">&quot;projection&quot;</span>=&gt;{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dv">1</span>}, <span class="st">&quot;limit&quot;</span>=&gt;<span class="dv">1</span>}
 =&gt; <span class="dv">false</span> </code></pre>
<pre class="shell"><code>$ rspec spec/race_results_spec.rb -e rq03</code></pre></li>
</ol>
<h3 id="implement-racersresults-cross-collection-relationships">Implement <code>racers</code>/<code>results</code> Cross-Collection Relationships</h3>
<p>In this section you will implement model class aspects that cross the boundary between the <code>racers</code> and <code>results</code> collections.</p>
<div class="figure">
<img src="docs/rsz_racers_results_cross_collection.png" alt="Racers-Results Cross Collection" /><p class="caption">Racers-Results Cross Collection</p>
</div>
<p><a href="docs/rsz_racers_results_cross_collection.png"><code>Racers-Results Cross Collection</code></a></p>
<ol style="list-style-type: decimal">
<li><p>Implement the bi-directional 1:1 embedded polymorphic relationship between <code>Entrant</code> and <code>RacerInfo</code>. <code>Racer</code> also holds a copy of this information and will be considered the master copy. <code>Entrant</code> will store a copy for the purpose of accessing during race result processing. The <code>RacerInfo</code> class was fully implemented during an earlier requirement. In the <code>Entrant</code> class, you must:</p>
<ul>
<li>name the <code>embeds_one</code> relationship <code>racer</code></li>
<li>define the <code>embeds_one</code> relationship polymorphic type as <code>parent</code></li>
<li>map the <code>racer</code> relationship to the <code>RacerInfo</code> class. Otherwise Mongoid will attempt to embed the root level <code>Racer</code> class by default.</li>
</ul>
<p>You can demonstrate your new relationship using the rails console. In the following example, we locate a <code>Racer</code> and <code>Entrant</code> created earlier (you can create new ones if required) and clone the <code>RacerInfo</code> from the <code>Racer</code> into the <code>Entrant</code>. The result is a compound document containing race-specific and racer-specific information.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; racer=<span class="dt">Racer</span>.where(:<span class="st">&quot;info.fn&quot;</span>=&gt;<span class="st">&quot;cat&quot;</span>, :<span class="st">&quot;info.ln&quot;</span>=&gt;<span class="st">&quot;inhat&quot;</span>).first
&gt; entrant=<span class="dt">Entrant</span>.find_by(<span class="st">:bib=</span>&gt;<span class="dv">1</span>)
&gt; entrant.create_racer(racer.info.attributes)
<span class="dt">Overwriting</span> existing field _id <span class="kw">in</span> <span class="kw">class</span> <span class="dt">RacerInfo</span>.
&gt; pp <span class="dt">Entrant</span>.find(entrant.id).attributes
{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;5678cec8e301d0e5e2000031&#39;</span>),
 <span class="st">&quot;bib&quot;</span>=&gt;<span class="dv">1</span>,
 <span class="st">&quot;secs&quot;</span>=&gt;<span class="fl">1100.123</span>,
 <span class="st">&quot;o&quot;</span>=&gt;{<span class="st">&quot;place&quot;</span>=&gt;<span class="dv">10</span>},
 <span class="st">&quot;gender&quot;</span>=&gt;{<span class="st">&quot;name&quot;</span>=&gt;<span class="st">&quot;M&quot;</span>, <span class="st">&quot;place&quot;</span>=&gt;<span class="dv">8</span>},
 <span class="st">&quot;group&quot;</span>=&gt;{<span class="st">&quot;name&quot;</span>=&gt;<span class="st">&quot;masters&quot;</span>, <span class="st">&quot;place&quot;</span>=&gt;<span class="dv">5</span>},
 <span class="st">&quot;updated_at&quot;</span>=&gt;<span class="dv">2015-12-22</span> <span class="bn">04</span>:<span class="dv">18</span>:<span class="dv">40</span> <span class="dt">UTC</span>,
 <span class="st">&quot;created_at&quot;</span>=&gt;<span class="dv">2015-12-22</span> <span class="bn">04</span>:<span class="dv">18</span>:<span class="dv">40</span> <span class="dt">UTC</span>,
 <span class="st">&quot;racer&quot;</span>=&gt;
  {<span class="st">&quot;fn&quot;</span>=&gt;<span class="st">&quot;cat&quot;</span>,
   <span class="st">&quot;ln&quot;</span>=&gt;<span class="st">&quot;inhat&quot;</span>,
   <span class="st">&quot;g&quot;</span>=&gt;<span class="st">&quot;M&quot;</span>,
   <span class="st">&quot;yr&quot;</span>=&gt;<span class="dv">1940</span>,
   <span class="st">&quot;res&quot;</span>=&gt;
    {<span class="st">&quot;city&quot;</span>=&gt;<span class="st">&quot;Oakland&quot;</span>,
     <span class="st">&quot;state&quot;</span>=&gt;<span class="st">&quot;CA&quot;</span>,
     <span class="st">&quot;loc&quot;</span>=&gt;{<span class="st">&quot;type&quot;</span>=&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">&quot;coordinates&quot;</span>=&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>]}},
   <span class="st">&quot;racer_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;568070e3e301d07bcf000012&#39;</span>),
   <span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;568070e3e301d07bcf000012&#39;</span>)}}</code></pre>
<p>Your focus above should have been on the fact that a copy of the <code>RacerInfo</code> is now embedded within the <code>Entrant</code>. If we inspect both the <code>racer.info</code> and <code>entrant.info</code>, we see the same state is represented. It is also verify important that your database document for <code>entrant.racer</code> have the <code>racer_id</code> property. This was a field we custom mapped to represent <code>_id</code> and represents our foreign key to the <code>Racer</code>.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; racer.info
 =&gt; <span class="co">#&lt;RacerInfo _id: 56a5aedce301d09b38000003, racer_id(id): nil, fn(first_name): &quot;cat&quot;, </span>
    ln(last_name): <span class="st">&quot;inhat&quot;</span>, g(gender): <span class="st">&quot;M&quot;</span>, yr(birth_year): <span class="dv">1940</span>, res(residence):
    {<span class="st">&quot;city&quot;</span>=&gt;<span class="st">&quot;Oakland&quot;</span>, <span class="st">&quot;state&quot;</span>=&gt;<span class="st">&quot;CA&quot;</span>, <span class="st">&quot;loc&quot;</span>=&gt;{<span class="st">&quot;type&quot;</span>=&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">&quot;coordinates&quot;</span>=&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>]}}&gt; 
&gt; entrant.racer
 =&gt; <span class="co">#&lt;RacerInfo _id: 56a5aedce301d09b38000003, racer_id(id): nil, fn(first_name): &quot;cat&quot;, </span>
    ln(last_name): <span class="st">&quot;inhat&quot;</span>, g(gender): <span class="st">&quot;M&quot;</span>, yr(birth_year): <span class="dv">1940</span>, res(residence):
    {<span class="st">&quot;city&quot;</span>=&gt;<span class="st">&quot;Oakland&quot;</span>, <span class="st">&quot;state&quot;</span>=&gt;<span class="st">&quot;CA&quot;</span>, <span class="st">&quot;loc&quot;</span>=&gt;{<span class="st">&quot;type&quot;</span>=&gt;<span class="st">&quot;Point&quot;</span>, <span class="st">&quot;coordinates&quot;</span>=&gt;[-<span class="fl">122.27</span>, <span class="fl">37.8</span>]}}&gt; </code></pre>
<p><code>RacerInfo</code> already has validation defined. In this example, we show that <code>Entrant</code> will be invalid if <code>RacerInfo</code> is invalid.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; entrant=<span class="dt">Entrant</span>.new          
&gt; racer=entrant.build_racer    
&gt; entrant.validate             
 =&gt; <span class="dv">false</span> 
&gt; entrant.errors.messages      
 =&gt; {<span class="st">:racer=</span>&gt;[<span class="st">&quot;is invalid&quot;</span>]} 
&gt; pp racer.errors.messages
{<span class="st">:first_name=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>],
 <span class="st">:last_name=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>],
 <span class="st">:gender=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>, <span class="st">&quot;must be M or F&quot;</span>],
 <span class="st">:birth_year=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>, <span class="st">&quot;must in past&quot;</span>]}</code></pre>
<pre class="shell"><code>$ rspec spec/racer_results_spec.rb -e rq01</code></pre></li>
<li><p>Implement the 1:M relationship between <code>Racer</code> and <code>Entrant</code>. The foreign key will be stored in the <code>Entrant.RacerInfo</code> embedded class. The <code>Racer</code> class must:</p>
<ul>
<li>name the <code>has_many</code> relationship <code>races</code></li>
<li>map the <code>has_many</code> relationship to the <code>Entrant</code> model class</li>
<li>map the <code>has_many</code> relationship foreign key to the <code>racer.racer_id</code> document key</li>
<li>define <code>has_many</code> relationship with a dependent constraint of <code>:nullify</code></li>
<li>define <code>has_many</code> relationship with a default sort order of <code>race.date</code>, DESCENDING. (<strong>Hint</strong>: <code>order: :&quot;race.date&quot;.desc</code>. The rspec test will not pass if you use an array notation here)</li>
</ul>
<p>You can demonstrate your new method with the query application logic using the rails console. In the following example an existing <code>Racer</code> with an extisting <code>Entrant</code> is retrieved and queried for <code>races</code>. The result is a collection of <code>Entrants</code> (with just the only one (1)).</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; racer=<span class="dt">Racer</span>.where(:<span class="st">&quot;info.fn&quot;</span>=&gt;<span class="st">&quot;cat&quot;</span>, :<span class="st">&quot;info.ln&quot;</span>=&gt;<span class="st">&quot;inhat&quot;</span>).first
&gt; racer.races.to_a
=&gt; [<span class="co">#&lt;Entrant _id: 5678cec8e301d0e5e2000031, </span>
     created_at: <span class="dv">2015-12-22</span> <span class="bn">04</span>:<span class="dv">18</span>:<span class="dv">40</span> <span class="dt">UTC</span>, updated_at: <span class="dv">2015-12-22</span> <span class="bn">04</span>:<span class="dv">18</span>:<span class="dv">40</span> <span class="dt">UTC</span>, bib: <span class="dv">1</span>, 
     secs: <span class="fl">1100.123</span>, entr
     o(overall): {<span class="st">&quot;place&quot;</span>=&gt;<span class="dv">10</span>}, 
     gender: {<span class="st">&quot;name&quot;</span>=&gt;<span class="st">&quot;M&quot;</span>, <span class="st">&quot;place&quot;</span>=&gt;<span class="dv">8</span>}, 
     group: {<span class="st">&quot;name&quot;</span>=&gt;<span class="st">&quot;masters&quot;</span>, <span class="st">&quot;place&quot;</span>=&gt;<span class="dv">5</span>}, race_id: <span class="dv">nil</span>&gt;] </code></pre>
<p><strong>Hint</strong>: If your <code>Racer</code> does not show any entrants in the collection it could be because we are specifying the foreign key as <code>race.racer_id</code> and your <code>RacerInfo</code> is not successfully mapping <code>_id</code> to <code>racer_id</code>.</p>
<pre class="shell"><code>$ rspec spec/racer_results_spec.rb -e rq02</code></pre></li>
</ol>
<h3 id="implement-attribute-delegation">Implement Attribute Delegation</h3>
<p>Before we build the web interface there are a few data tier interface issues we need to address and simplify to be able to work with the default views that Rails scaffold will generate for us.</p>
<ul>
<li>nested data</li>
<li>custom type properties</li>
</ul>
<p>The generated views work much better out-of-the-box when we hide the fact that we have used embedded classes. For example, the generate view just wants to access the <code>Entrant.race_date</code> or the <code>Racer.city</code> and not have to know to access the <code>Entrant.race.date</code> or the <code>Racer.info.residence.city</code>. In addition, the view would get undesirably complicated with nil checks as they navigated the nested document tree. Since our focus is on the data tier and a quick/easy visualization of the data tier, we are going to solve the access facade here.</p>
<p>To solve the nesting issue in the data tier, you may use brute-force to implement setters and getters for nested data or make use of of Active Model's <a href="http://api.rubyonrails.org/classes/Module.html#method-i-delegate"><code>delegate</code></a> feature, which allows us to define getter/setter methods in the parent class and delegate them to the nested objects holding the information. Everything appears to be at the parent level from the external view.</p>
<p>To complicate matters, Mongoid manages the custom types differently. Every access to the custom type appears to invoke a call to <code>demongoize</code> from a database hash form. You cannot get the instance, set a property of the instance, and have that have any affect without replacing the entire instance with the values you want in place. We can also hide this complexity with brute force using custom setters and getters. However, those extra checks can get tedious when repeated for each property in the custom type. To simplify this issue we will show Ruby's <a href="https://rubymonk.com/learning/books/2-metaprogramming-ruby/chapters/25-dynamic-methods/lessons/72-define-method"><code>metaprogramming</code></a> features, which allows us to dynamically add methods to parent classes using an abstract definition.</p>
<p>Lets make interface simplifications to the <code>Racer</code>, <code>Race</code>, and <code>Entrant</code> classes. Since this was not specifically covered within class, much of the code will be provided for you.</p>
<ol style="list-style-type: decimal">
<li><p>Implement a flattened view of properties in the <code>Racer</code> such that the following already implemented properties are available to the view.</p>
<ul>
<li>expose <code>info.first_name</code> as <code>first_name</code></li>
<li>expose <code>info.last_name</code> as <code>last_name</code></li>
<li>expose <code>info.gender</code> as <code>gender</code></li>
<li>expose <code>info.birth_year</code> as <code>birth_year</code></li>
<li>expose <code>info.residence.city</code> as <code>city</code></li>
<li>expose <code>info.residence.state</code> as <code>state</code></li>
</ul>
<p><strong>Hint</strong>: In the <code>Racer</code> class, add delegation specifications for the following properties.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">class</span> <span class="dt">Racer</span>
  ...
  delegate <span class="st">:first_name</span>, <span class="st">:first_name=</span>, to: <span class="st">:info</span>
  delegate <span class="st">:last_name</span>, <span class="st">:last_name=</span>, to: <span class="st">:info</span>
  delegate <span class="st">:gender</span>, <span class="st">:gender=</span>, to: <span class="st">:info</span>
  delegate <span class="st">:birth_year</span>, <span class="st">:birth_year=</span>, to: <span class="st">:info</span>
  delegate <span class="st">:city</span>, <span class="st">:city=</span>, to: <span class="st">:info</span>
  delegate <span class="st">:state</span>, <span class="st">:state=</span>, to: <span class="st">:info</span></code></pre>
<p>With the delegation in place, you can demonstrate some functionality for the properties maintained directly within <code>RacerInfo</code> but not yet for <code>city</code> and <code>state</code>. In the example below, we start with a mass assignment of the <code>RacerInfo</code> properties passed to <code>Racer</code> and having them delegated to their proper locations. We can call the getter/setters at each level and arrive at the same value. The stored document shows the information embedded within the <code>info</code> property.</p>
<strong>Hint</strong>: If you get <code>Mongoid::Errors::UnknownAttribute:</code>
<ul>
<li>re-check your mappings</li>
<li>verify you have saved your editor with the mappings</li>
<li>verify you have executed <code>reload!</code> within the rails console to pick up the new mappings</li>
</ul>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; racer=<span class="dt">Racer</span>.new(<span class="st">:first_name=</span>&gt;<span class="st">&quot;thing&quot;</span>,<span class="st">:last_name=</span>&gt;<span class="st">&quot;two&quot;</span>,<span class="st">:gender=</span>&gt;<span class="st">&quot;M&quot;</span>,<span class="st">:birth_year=</span>&gt;<span class="dv">1960</span>)
&gt; racer.info.last_name
 =&gt; <span class="st">&quot;two&quot;</span> 
&gt; racer.last_name
 =&gt; <span class="st">&quot;two&quot;</span> 
&gt; racer.last_name=<span class="st">&quot;three&quot;</span>
 =&gt; <span class="st">&quot;three&quot;</span> 
&gt; racer.validate
 =&gt; <span class="dv">true</span> 
&gt; racer.save
&gt; pp <span class="dt">Racer</span>.find(racer.id).attributes
{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;568874bae301d009f0000084&#39;</span>),
 <span class="st">&quot;info&quot;</span>=&gt;
  {<span class="st">&quot;fn&quot;</span>=&gt;<span class="st">&quot;thing&quot;</span>,
   <span class="st">&quot;ln&quot;</span>=&gt;<span class="st">&quot;three&quot;</span>,
   <span class="st">&quot;g&quot;</span>=&gt;<span class="st">&quot;M&quot;</span>,
   <span class="st">&quot;yr&quot;</span>=&gt;<span class="dv">1960</span>,
   <span class="st">&quot;racer_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;568874bae301d009f0000084&#39;</span>)}}</code></pre>
<p><strong>Hint(s)</strong>: To compensate for the getter/setter versus bulk replacement issue for custom types, we could consider adding the following logic to the <code>RacerInfo</code> class. This would work. The getter handles the case where the residence is nil and the setter makes sure to do a bulk assignment using an instance initialized with the current values.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">class</span> <span class="dt">RacerInfo</span>
  <span class="kw">def</span> city
    <span class="dv">self</span>.residence ? <span class="dv">self</span>.residence.city : <span class="dv">nil</span>
  <span class="kw">end</span>
  <span class="kw">def</span> city= name
    object=<span class="dv">self</span>.residence ||= <span class="dt">Address</span>.new
    object.city=name
    <span class="dv">self</span>.residence=object
  <span class="kw">end</span></code></pre>
<p>However, the above brute force solution repeated for each property becomes tedious by unnecessarily having to repeat the same block of code for each property in the custom type and you may want to use the next approach. Consider instead leveraging <code>metaprogramming</code> and dynamically create a getter/setter of the above design for each property we care about.</p>
<ul>
<li><code>define_method</code> declares a block of code that defines a particular method and that method can optionally take parameters (e.g., <code>do |action|</code>)</li>
<li><p><code>object.send(&quot;m&quot;,123)</code> invokes a method (&quot;m&quot;) on the object and can optionally pass parameters to that method (e.g., 123)</p>
<ul>
<li>just as <code>name and name=(param)</code> are getter and setters for name -- <code>object.send(&quot;name&quot;) and object.send(&quot;name=&quot;, value)</code> are also getter and setter methods that can dynamically access object methods without knowing the type ahead of time.</li>
</ul></li>
</ul>
<p>The following code block demonstrates creating a getter and setter method for each of our <code>Address</code> properties within the <code>RacerInfo</code> class -- making sure to apply the single field change to an entire instance of Account that was created from the current state and re-assigned as a whole object.</p>
<ul>
<li><code>city</code> and <code>state</code> are defined in an array that is passed in as the <code>action</code> to perform</li>
<li>two methods are created; <code>(action)</code> and <code>(action)=</code> to act as the getter and setter for that property</li>
<li>both perform nil checks on the residence</li>
<li>the getter pulls the desired field from the embedded custom type</li>
<li>the setter applies the value to the desired field and re-assigns the state for the the entire custom type</li>
</ul>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">class</span> <span class="dt">RacerInfo</span>
  ...
  [<span class="st">&quot;city&quot;</span>, <span class="st">&quot;state&quot;</span>].each <span class="kw">do</span> |action|
    define_method(<span class="st">&quot;</span><span class="ot">#{</span>action<span class="ot">}</span><span class="st">&quot;</span>) <span class="kw">do</span> 
      <span class="dv">self</span>.residence ? <span class="dv">self</span>.residence.send(<span class="st">&quot;</span><span class="ot">#{</span>action<span class="ot">}</span><span class="st">&quot;</span>) : <span class="dv">nil</span>
    <span class="kw">end</span>
    define_method(<span class="st">&quot;</span><span class="ot">#{</span>action<span class="ot">}</span><span class="st">=&quot;</span>) <span class="kw">do</span> |name|
      object=<span class="dv">self</span>.residence ||= <span class="dt">Address</span>.new
      object.send(<span class="st">&quot;</span><span class="ot">#{</span>action<span class="ot">}</span><span class="st">=&quot;</span>, name)
      <span class="dv">self</span>.residence=object
    <span class="kw">end</span>
  <span class="kw">end</span></code></pre>
<p><strong>Hint</strong>: The call to <code>Address.new</code> relies on the fact that there is an <code>Address</code>.initialize()` that will accept no arguments. Make adjustments to your implementation as necessary to create a default instance.</p>
<p>You can now demonstrate the rest of your flattened embedded fields using the rails console. The following shows the <code>city</code> and <code>state</code> being accessed thru the dynamically added setters and getters and these methods performing the logic required to make sure out <code>RacerInfo</code> gets updated properly with <code>Address</code> information.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; racer=<span class="dt">Racer</span>.find(racer.id)
&gt; racer.city
 =&gt; <span class="dv">nil</span> 
&gt; racer.city=<span class="st">&quot;Oakland&quot;</span>
 =&gt; <span class="st">&quot;Oakland&quot;</span> 
&gt; racer.state=<span class="st">&quot;CA&quot;</span>
&gt; racer.info.residence
 =&gt; <span class="co">#&lt;Address:0x000000053b6258 @city=&quot;Oakland&quot;, @state=&quot;CA&quot;, @location=nil&gt; </span>
&gt; racer.save
&gt; pp <span class="dt">Racer</span>.find(racer.id).attributes
{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;568874bae301d009f0000084&#39;</span>),
 <span class="st">&quot;info&quot;</span>=&gt;
  {<span class="st">&quot;fn&quot;</span>=&gt;<span class="st">&quot;thing&quot;</span>,
   <span class="st">&quot;ln&quot;</span>=&gt;<span class="st">&quot;three&quot;</span>,
   <span class="st">&quot;g&quot;</span>=&gt;<span class="st">&quot;M&quot;</span>,
   <span class="st">&quot;yr&quot;</span>=&gt;<span class="dv">1960</span>,
   <span class="st">&quot;racer_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;568874bae301d009f0000084&#39;</span>),
   <span class="st">&quot;res&quot;</span>=&gt;{<span class="st">&quot;city&quot;</span>=&gt;<span class="st">&quot;Oakland&quot;</span>, <span class="st">&quot;state&quot;</span>=&gt;<span class="st">&quot;CA&quot;</span>}}}</code></pre>
<pre class="shell"><code>$ rspec spec/flatten_attributes_spec.rb -e rq01</code></pre></li>
<li><p>Implement a flattened and default configuration for <code>Race</code>. The class must:</p>
<ul>
<li>have properties called <code>swim_order</code>, <code>swim_distance</code>, and <code>swim_units</code> that default to 0, 1, and &quot;miles&quot;</li>
<li>have a property called <code>t1_order</code> that defaults to 1</li>
<li>have properties called <code>bike_order</code>, <code>bike_distance</code>, and <code>bike_units</code> that default to 2, 25, and &quot;miles&quot;</li>
<li>have a property called <code>t2_order</code> that defaults to 3</li>
<li>have properties called <code>run_order</code>, <code>run_distance</code>, and <code>run_units</code> that default to 4, 10, and &quot;kilometers&quot;</li>
<li>have the ability to get and set each of the above event properties</li>
<li>have a class method called <code>default</code> that returns a default instance of <code>Race</code> with the above properties</li>
<li>expose <code>location.city</code> as <code>city</code></li>
<li>expose <code>location.state</code> as <code>state</code></li>
</ul>
<p><strong>Hint</strong>: It would likely help to start with a data hash that defines the default properties.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">DEFAULT_EVENTS</span> = {<span class="st">&quot;swim&quot;</span>=&gt;{<span class="st">:order=</span>&gt;<span class="dv">0</span>, <span class="st">:name=</span>&gt;<span class="st">&quot;swim&quot;</span>, <span class="st">:distance=</span>&gt;<span class="fl">1.0</span>, <span class="st">:units=</span>&gt;<span class="st">&quot;miles&quot;</span>},
                  <span class="st">&quot;t1&quot;</span>=&gt;  {<span class="st">:order=</span>&gt;<span class="dv">1</span>, <span class="st">:name=</span>&gt;<span class="st">&quot;t1&quot;</span>},
                  <span class="st">&quot;bike&quot;</span>=&gt;{<span class="st">:order=</span>&gt;<span class="dv">2</span>, <span class="st">:name=</span>&gt;<span class="st">&quot;bike&quot;</span>, <span class="st">:distance=</span>&gt;<span class="fl">25.0</span>, <span class="st">:units=</span>&gt;<span class="st">&quot;miles&quot;</span>},
                  <span class="st">&quot;t2&quot;</span>=&gt;  {<span class="st">:order=</span>&gt;<span class="dv">3</span>, <span class="st">:name=</span>&gt;<span class="st">&quot;t2&quot;</span>},
                  <span class="st">&quot;run&quot;</span>=&gt; {<span class="st">:order=</span>&gt;<span class="dv">4</span>, <span class="st">:name=</span>&gt;<span class="st">&quot;run&quot;</span>, <span class="st">:distance=</span>&gt;<span class="fl">10.0</span>, <span class="st">:units=</span>&gt;<span class="st">&quot;kilometers&quot;</span>}}</code></pre>
<p><strong>Hint</strong>: Your solution might use explicit methods written using brute force for each event and property.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> swim
  event=events.select {|event| <span class="st">&quot;swim&quot;</span>==event.name}.first
  event||=events.build(<span class="dt">DEFAULT_EVENTS</span>[<span class="st">&quot;swim&quot;</span>])
<span class="kw">end</span>
<span class="kw">def</span> swim_order
  swim.order
<span class="kw">end</span>
<span class="kw">def</span> swim_distance
  swim.distance
<span class="kw">end</span>
<span class="kw">def</span> swim_units
  swim.units
<span class="kw">end</span></code></pre>
<p>However, you will likely find the following metadataprogramming definition helpful. The outer loop is driven by the keys of the DEFAULT_EVENT hash shown above and defines the implementation for getting and/or creating the event. The inner loop conditionally creates and getter/setter for the lower-level property if a value exists in the hash.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">DEFAULT_EVENTS</span>.keys.each <span class="kw">do</span> |name|
  define_method(<span class="st">&quot;</span><span class="ot">#{</span>name<span class="ot">}</span><span class="st">&quot;</span>) <span class="kw">do</span> 
    event=events.select {|event| name==event.name}.first
    event||=events.build(<span class="dt">DEFAULT_EVENTS</span>[<span class="st">&quot;</span><span class="ot">#{</span>name<span class="ot">}</span><span class="st">&quot;</span>])
  <span class="kw">end</span>
  [<span class="st">&quot;order&quot;</span>,<span class="st">&quot;distance&quot;</span>,<span class="st">&quot;units&quot;</span>].each <span class="kw">do</span> |prop|
    <span class="kw">if</span> <span class="dt">DEFAULT_EVENTS</span>[<span class="st">&quot;</span><span class="ot">#{</span>name<span class="ot">}</span><span class="st">&quot;</span>][prop.to_sym]
      define_method(<span class="st">&quot;</span><span class="ot">#{</span>name<span class="ot">}</span><span class="st">_</span><span class="ot">#{</span>prop<span class="ot">}</span><span class="st">&quot;</span>) <span class="kw">do</span> 
        event=<span class="dv">self</span>.send(<span class="st">&quot;</span><span class="ot">#{</span>name<span class="ot">}</span><span class="st">&quot;</span>).send(<span class="st">&quot;</span><span class="ot">#{</span>prop<span class="ot">}</span><span class="st">&quot;</span>)
      <span class="kw">end</span>
      define_method(<span class="st">&quot;</span><span class="ot">#{</span>name<span class="ot">}</span><span class="st">_</span><span class="ot">#{</span>prop<span class="ot">}</span><span class="st">=&quot;</span>) <span class="kw">do</span> |value|
        event=<span class="dv">self</span>.send(<span class="st">&quot;</span><span class="ot">#{</span>name<span class="ot">}</span><span class="st">&quot;</span>).send(<span class="st">&quot;</span><span class="ot">#{</span>prop<span class="ot">}</span><span class="st">=&quot;</span>, value)
      <span class="kw">end</span>
    <span class="kw">end</span>
  <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<p>You can demonstrate your flattened <code>Race</code> class with default properties using the rails console. In the following example a new <code>Race</code> is created. A default <code>swim</code> is added once accessed. A default <code>bike</code> is added once the <code>bike_distance</code> is accessed. A default <code>run</code> is added once the <code>run_distance=</code> is accessed to set the event to 222 miles.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race=<span class="dt">Race</span>.new
 &gt; race.swim
 =&gt; <span class="co">#&lt;Event _id: 56889d46e301d009f00000c6, o(order): 0, n(name): &quot;swim&quot;, d(distance): 1.0, u(units): &quot;miles&quot;&gt; </span>
 &gt; race.bike_distance
 =&gt; <span class="fl">25.0</span> 
 &gt; race.run_distance=<span class="dv">222</span>
 =&gt; <span class="dv">222</span> 
&gt; pp race.events.to_a
[<span class="co">#&lt;Event _id: 56889d46e301d009f00000c6, o(order): 0, n(name): &quot;swim&quot;, d(distance): 1.0, u(units): &quot;miles&quot;&gt;,</span>
 <span class="co">#&lt;Event _id: 56889d7ae301d009f00000c7, o(order): 2, n(name): &quot;bike&quot;, d(distance): 25.0, u(units): &quot;miles&quot;&gt;,</span>
 <span class="co">#&lt;Event _id: 56889d7ae301d009f00000c8, o(order): 4, n(name): &quot;run&quot;, d(distance): 222.0, u(units): &quot;kilometers&quot;&gt;]</span></code></pre>
<p><strong>Hint</strong>: Given a source of event keys (e.g., <code>DEFAULT_EVENTS.keys</code>), it would be easy to implement a default instance of the <code>Race</code> in the following manner.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> <span class="dv">self</span>.default 
  <span class="dt">Race</span>.new <span class="kw">do</span> |race|
    <span class="dt">DEFAULT_EVENTS</span>.keys.each {|leg|race.send(<span class="st">&quot;</span><span class="ot">#{</span>leg<span class="ot">}</span><span class="st">&quot;</span>)}
  <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race=<span class="dt">Race</span>.default
&gt; race.save
&gt; pp <span class="dt">Race</span>.find(race.id).attributes
{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56995119e301d0330000005d&#39;</span>),
 <span class="st">&quot;next_bib&quot;</span>=&gt;<span class="dv">0</span>,
 <span class="st">&quot;updated_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-15</span> <span class="dv">20</span>:<span class="bn">06</span>:<span class="bn">01</span> <span class="dt">UTC</span>,
 <span class="st">&quot;created_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-15</span> <span class="dv">20</span>:<span class="bn">06</span>:<span class="bn">01</span> <span class="dt">UTC</span>,
 <span class="st">&quot;events&quot;</span>=&gt;
  [{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56995129e301d0330000005e&#39;</span>),
    <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">0</span>,
    <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;swim&quot;</span>,
    <span class="st">&quot;d&quot;</span>=&gt;<span class="fl">1.0</span>,
    <span class="st">&quot;u&quot;</span>=&gt;<span class="st">&quot;miles&quot;</span>},
   {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56995129e301d0330000005f&#39;</span>), <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">1</span>, <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;t1&quot;</span>},
   {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56995129e301d03300000060&#39;</span>),
    <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">2</span>,
    <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;bike&quot;</span>,
    <span class="st">&quot;d&quot;</span>=&gt;<span class="fl">25.0</span>,
    <span class="st">&quot;u&quot;</span>=&gt;<span class="st">&quot;miles&quot;</span>},
   {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56995129e301d03300000061&#39;</span>), <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">3</span>, <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;t2&quot;</span>},
   {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56995129e301d03300000062&#39;</span>),
    <span class="st">&quot;o&quot;</span>=&gt;<span class="dv">4</span>,
    <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;run&quot;</span>,
    <span class="st">&quot;d&quot;</span>=&gt;<span class="fl">10.0</span>,
    <span class="st">&quot;u&quot;</span>=&gt;<span class="st">&quot;kilometers&quot;</span>}]}</code></pre>
<p>We can use the technique we used in the <code>RacerInfo</code> class to provided flattened access to <code>city</code> and <code>state</code> within <code>Race.location</code></p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">class</span> <span class="dt">Race</span>
  ...
  [<span class="st">&quot;city&quot;</span>, <span class="st">&quot;state&quot;</span>].each <span class="kw">do</span> |action|
    define_method(<span class="st">&quot;</span><span class="ot">#{</span>action<span class="ot">}</span><span class="st">&quot;</span>) <span class="kw">do</span> 
      <span class="dv">self</span>.location ? <span class="dv">self</span>.location.send(<span class="st">&quot;</span><span class="ot">#{</span>action<span class="ot">}</span><span class="st">&quot;</span>) : <span class="dv">nil</span>
    <span class="kw">end</span>
    define_method(<span class="st">&quot;</span><span class="ot">#{</span>action<span class="ot">}</span><span class="st">=&quot;</span>) <span class="kw">do</span> |name|
      object=<span class="dv">self</span>.location ||= <span class="dt">Address</span>.new
      object.send(<span class="st">&quot;</span><span class="ot">#{</span>action<span class="ot">}</span><span class="st">=&quot;</span>, name)
      <span class="dv">self</span>.location=object
    <span class="kw">end</span>
  <span class="kw">end</span></code></pre>
<p>You can now demonstrate your completed <code>Race</code> class with flattened properties for all events and location information. The following example shows a <code>Race</code> being created and passed into a block where a set of methods are invoked against the <code>Race</code>. The output is displayed on the following lines.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">Race</span>.new(city:<span class="st">&quot;LA&quot;</span>,state:<span class="st">&quot;CA&quot;</span>).tap {|race|
      [<span class="st">&quot;swim_order&quot;</span>,<span class="st">&quot;t1&quot;</span>,<span class="st">&quot;bike_distance&quot;</span>,<span class="st">&quot;t2&quot;</span>,<span class="st">&quot;run_units&quot;</span>,<span class="st">&quot;city&quot;</span>,<span class="st">&quot;state&quot;</span>].map {|event|
        pp race.send(event)
     }
   }
<span class="dv">0</span>
<span class="co">#&lt;Event _id: 5688a11ae301d009f00000d5, o(order): 1, n(name): &quot;t1&quot;, d(distance): nil, u(units): nil&gt;</span>
<span class="fl">25.0</span>
<span class="co">#&lt;Event _id: 5688a11ae301d009f00000d6, o(order): 3, n(name): &quot;t2&quot;, d(distance): nil, u(units): nil&gt;</span>
<span class="st">&quot;kilometers&quot;</span>
<span class="st">&quot;LA&quot;</span>
<span class="st">&quot;CA&quot;</span></code></pre>
<pre class="shell"><code>$ rspec spec/flatten_attributes_spec.rb -e rq02</code></pre></li>
<li><p>Add flattened property support to your <code>Entrant</code> class relative to <code>Race</code> and <code>Racer</code>. This class must:</p>
<ul>
<li>expose <code>racer.first_name</code> as <code>first_name</code></li>
<li>expose <code>racer.last_name</code> as <code>last_name</code></li>
<li>expose <code>racer.gender</code> as <code>racer_gender</code> (<strong>Hint</strong>: note the prefix)</li>
<li>expose <code>racer.birth_year</code> as <code>birth_year</code></li>
<li>expose <code>racer.residence.city</code> as <code>city</code></li>
<li>expose <code>racer.residence.state</code> as <code>state</code></li>
<li>expose <code>race.name</code> as <code>race_name</code></li>
<li>expose <code>race.date</code> as <code>race_date</code></li>
<li>expose <code>group.name</code> as <code>group_name</code> and returning nil if group does not exist</li>
<li>expose <code>group.place</code> as <code>group_place</code> and returning nil if group does not exist</li>
<li>expose <code>overall.place</code> as <code>overall_place</code> and returning nil if overall does not exist</li>
<li><p>expose <code>gender.place</code> as <code>gender_place</code> and returning nil if gender does not exist</p></li>
<li><p>add <code>autobuild</code> to the <code>race</code> and <code>racer</code> <code>embeds_one</code> relation so that we can guarantee that the embeded instances will be in place to hold properties when accessed and updated.</p></li>
</ul>
<p><strong>Hint</strong>: The <code>RacerInfo</code> properties can be handled the same as we did with <code>Race</code> with the use of <code>delegate</code> but a different property name. To get <code>racer_</code> prefix added to the <code>gender</code> property, add a <code>prefix</code> specification to the definition.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">delegate <span class="st">:first_name</span>, <span class="st">:first_name=</span>, to: <span class="st">:racer</span>
delegate <span class="st">:last_name</span>, <span class="st">:last_name=</span>, to: <span class="st">:racer</span>
delegate <span class="st">:gender</span>, <span class="st">:gender=</span>, to: <span class="st">:racer</span>, prefix: <span class="st">&quot;racer&quot;</span>
delegate <span class="st">:birth_year</span>, <span class="st">:birth_year=</span>, to: <span class="st">:racer</span>
delegate <span class="st">:city</span>, <span class="st">:city=</span>, to: <span class="st">:racer</span>
delegate <span class="st">:state</span>, <span class="st">:state=</span>, to: <span class="st">:racer</span></code></pre>
<p><strong>Hint</strong>: The <code>RaceRef</code> properties require a <code>race_</code> prefix added to the property and can also be handled by delegate with a prefix specified.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">delegate <span class="st">:name</span>, <span class="st">:name=</span>, to: <span class="st">:race</span>, prefix: <span class="st">&quot;race&quot;</span>
delegate <span class="st">:date</span>, <span class="st">:date=</span>, to: <span class="st">:race</span>, prefix: <span class="st">&quot;race&quot;</span></code></pre>
<p><strong>Hint</strong>: The nil check delegation to the custom classes would be easiest implemented through a set of custom accessor methods.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> overall_place
  overall.place <span class="kw">if</span> overall
<span class="kw">end</span>
<span class="kw">def</span> gender_place
  gender.place <span class="kw">if</span> gender
<span class="kw">end</span>
<span class="kw">def</span> group_name
  group.name <span class="kw">if</span> group
<span class="kw">end</span>
<span class="kw">def</span> group_place
  group.place <span class="kw">if</span> group
<span class="kw">end</span></code></pre>
<p><strong>Hint</strong>: Don't forget to add <code>autobuild</code> to the two <code>embeds_one</code> relationships so the embedded objects will be created when needed.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">embeds_one <span class="st">:race</span>, class_name: <span class="st">&quot;RaceRef&quot;</span>, autobuild: <span class="dv">true</span>
embeds_one <span class="st">:racer</span>, class_name: <span class="st">&quot;RacerInfo&quot;</span>, as: <span class="st">:parent</span>, autobuild: <span class="dv">true</span></code></pre>
<p>With the delegates in place, you can demonstrate your flat access to <code>Entrant</code> properties using the rails console. The following example shows a root-level property and two embedded properties set in the <code>Entrant</code> and then accessed using reflection.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; [<span class="st">&quot;bib&quot;</span>,<span class="st">&quot;first_name&quot;</span>,<span class="st">&quot;race_name&quot;</span>].map {|prop| \
      <span class="dt">Entrant</span>.new(<span class="st">:bib=</span>&gt;<span class="dv">0</span>,<span class="st">:first_name=</span>&gt;<span class="st">&quot;thing&quot;</span>,<span class="st">:race_name=</span>&gt;<span class="st">&quot;123&quot;</span>).send(prop)}
 =&gt; [<span class="dv">0</span>, <span class="st">&quot;thing&quot;</span>, <span class="st">&quot;123&quot;</span>] </code></pre>
<p>We now should have an <code>Entrant</code> interface that the views can safely and simply access without nesting and nil checks.</p>
<pre class="shell"><code>$ rspec spec/flatten_attributes_spec.rb -e rq03</code></pre></li>
<li><p>Add flattened property support to your <code>Entrant</code> class relative to <code>LegResult</code>. The <code>Entrant</code> class must:</p>
<ul>
<li>have properties called <code>swim</code>, <code>t1</code>, <code>bike</code>, <code>t2</code>, <code>run</code> that map to events within the <code>events</code> collection found by <code>event.name</code> and are of type <code>SwimResult</code>, <code>LegResult</code>, <code>BikeResult</code>, <code>LegResult</code>, and <code>RunResult</code> respectively.</li>
<li>have properties called <code>swim_secs</code> and <code>swim_pace_100</code> that map to <code>swim.secs</code> and <code>swim.pace_100</code></li>
<li>have a property called <code>t1_secs</code> that maps to <code>t1.secs</code></li>
<li>have properties called <code>bike_secs</code> and <code>bike_mph</code> that maps to <code>bike.secs</code> and <code>bike.mph</code></li>
<li>have a property called <code>t2_secs</code> that maps to <code>t2.secs</code></li>
<li>have properties called <code>run_secs</code> and <code>run_mmile</code> that maps to <code>run.secs</code> and <code>run.mmile</code></li>
<li>have the ability to get and set each of the above event properties within the events found by <code>event.name</code></li>
</ul>
<p><strong>Hint</strong>: The above can be written out one-by-one and fully function. However, you may want to try metaprogramming to reduce much of the redundancy of code. We can start with a mapping of event names to result class implementations.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">RESULTS</span> = {<span class="st">&quot;swim&quot;</span>=&gt;<span class="dt">SwimResult</span>, 
           <span class="st">&quot;t1&quot;</span>=&gt;<span class="dt">LegResult</span>, 
           <span class="st">&quot;bike&quot;</span>=&gt;<span class="dt">BikeResult</span>, 
           <span class="st">&quot;t2&quot;</span>=&gt;<span class="dt">LegResult</span>, 
           <span class="st">&quot;run&quot;</span>=&gt;<span class="dt">RunResult</span>}</code></pre>
<p>We then can begin with an outer loop targeted at each event name.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">RESULTS</span>.keys.each <span class="kw">do</span> |name|
  <span class="co">#create_or_find result</span>
  <span class="co">#assign event details to result</span>
  <span class="co">#expose setter/getter for each property of each result </span>
<span class="kw">end</span></code></pre>
<p>Within the outer loop we can define our getter method for the event that will either find the event within the <code>events</code> collection or create a new one that has been inserted into the collection.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">  <span class="co">#create_or_find result</span>
  define_method(<span class="st">&quot;</span><span class="ot">#{</span>name<span class="ot">}</span><span class="st">&quot;</span>) <span class="kw">do</span> 
    result=results.select {|result| name==result.event.name <span class="kw">if</span> result.event}.first
    <span class="kw">if</span> !result
      result=<span class="dt">RESULTS</span>[<span class="st">&quot;</span><span class="ot">#{</span>name<span class="ot">}</span><span class="st">&quot;</span>].new(<span class="st">:event=</span>&gt;{<span class="st">:name=</span>&gt;name})
      results &lt;&lt; result
    <span class="kw">end</span>
    result
  <span class="kw">end</span></code></pre>
<p>The next block defines a method that will assign event details to a result. The previous getter method is used to locate or create the result and this will embed the details of the event in that result.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">  <span class="co">#assign event details to result</span>
  define_method(<span class="st">&quot;</span><span class="ot">#{</span>name<span class="ot">}</span><span class="st">=&quot;</span>) <span class="kw">do</span> |event|
    event=<span class="dv">self</span>.send(<span class="st">&quot;</span><span class="ot">#{</span>name<span class="ot">}</span><span class="st">&quot;</span>).build_event(event.attributes)
  <span class="kw">end</span></code></pre>
<p>Next we expose a getter/setter for each attribute in the result classes. This should end up adding a <code>_secs</code> and an event-specific property to the <code>Entrant</code> class. The setter method manually calls the collection callback to re-calculate the total <code>secs</code> since we are not changing the collection at this time -- only changing the result within the collection.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">  <span class="co">#expose setter/getter for each property of each result</span>
  <span class="dt">RESULTS</span>[<span class="st">&quot;</span><span class="ot">#{</span>name<span class="ot">}</span><span class="st">&quot;</span>].attribute_names.reject {|r|<span class="ot">/^_/</span>===r}.each <span class="kw">do</span> |prop|
    define_method(<span class="st">&quot;</span><span class="ot">#{</span>name<span class="ot">}</span><span class="st">_</span><span class="ot">#{</span>prop<span class="ot">}</span><span class="st">&quot;</span>) <span class="kw">do</span>
      event=<span class="dv">self</span>.send(name).send(prop)
    <span class="kw">end</span>
    define_method(<span class="st">&quot;</span><span class="ot">#{</span>name<span class="ot">}</span><span class="st">_</span><span class="ot">#{</span>prop<span class="ot">}</span><span class="st">=&quot;</span>) <span class="kw">do</span> |value|
      event=<span class="dv">self</span>.send(name).send(<span class="st">&quot;</span><span class="ot">#{</span>prop<span class="ot">}</span><span class="st">=&quot;</span>,value)
      update_total <span class="dv">nil</span>  <span class="kw">if</span> <span class="ot">/secs/</span>===prop
    <span class="kw">end</span>
  <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<p>With the wrapper methods in place, you can demonstrate your flattened <code>Entrant</code> class result properties using the rails console. In the following example we create a small race with just two legs; <code>swim</code> and <code>t1</code>. We then create an <code>Entrant</code> and assign the event details from the <code>Race</code> to the <code>Entrant.results</code>. Type-specific methods are beging called to create the correct sub-class of <code>LegResult</code>.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; entrant=<span class="dt">Entrant</span>.new
&gt; race=<span class="dt">Race</span>.new.tap {|race| [<span class="st">&quot;swim&quot;</span>,<span class="st">&quot;t1&quot;</span>].each {|event|race.send(event)}}
&gt; entrant.swim=race.swim
 =&gt; <span class="co">#&lt;Event _id: 5688d838e301d009f000016c, o(order): 0, n(name): &quot;swim&quot;, d(distance): 1.0, u(units): &quot;miles&quot;&gt; </span>
&gt; entrant.t1=race.t1
 =&gt; <span class="co">#&lt;Event _id: 5688d846e301d009f000016e, o(order): 1, n(name): &quot;t1&quot;, d(distance): nil, u(units): nil&gt; </span></code></pre>
<p>At this point we can assign times using <code>swim_secs</code> and <code>t1_secs</code> methods. This updates the overall time and stores the result with event-specific averages calculated.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"> &gt; entrant.swim_secs=<span class="dv">1000</span>
 =&gt; <span class="dv">1000</span> 
 &gt; entrant.t1_secs=<span class="dv">100</span>
 =&gt; <span class="dv">100</span> 
 &gt; entrant.secs
 =&gt; <span class="fl">1100.0</span> 
 &gt; pp entrant.results.to_a
[<span class="co">#&lt;SwimResult _id: 5688d74ae301d009f0000168, secs: 1000.0, _type: &quot;SwimResult&quot;, pace_100: 62.13727366498068&gt;,</span>
 <span class="co">#&lt;LegResult _id: 5688d74ae301d009f0000169, secs: 100.0, _type: &quot;LegResult&quot;&gt;]</span></code></pre>
<p>We can gain access to the specific properties using the flattened accessor methods.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; entrant.swim_pace_100
 =&gt; <span class="fl">62.13727366498068</span> 
&gt; entrant.swim_secs
 =&gt; <span class="fl">1000.0</span> </code></pre>
<pre class="shell"><code>$ rspec spec/flatten_attributes_spec.rb -e rq04</code></pre></li>
</ol>
<h3 id="implement-cross-collection-service-requests">Implement Cross-Collection Service Requests</h3>
<p>In this section we will implement logic that must leverage multiple collections to complete the use case. This is helper code for the web application to easily access with the model. We could have broken this out into separate service logic, but have wrapped it in the specific model classes in a small attempt to simplify the implementation and assignment.</p>
<ol style="list-style-type: decimal">
<li><p>Update the <code>Race</code> model class to support a centralized registry for bib numbers within a <code>Race</code>. We can tolerate gaps, but cannot have duplicates. The class must:</p>
<ul>
<li>add a new <code>next_bib</code> field as type Integer, mapped to the document key <code>next_bib</code>, and with a default value of 0. (<strong>Hint</strong>: assign a <a href="https://docs.mongodb.org/ecosystem/tutorial/mongoid-documents/#defaults">default value</a> at document creation time and not instance creation time)</li>
<li>override the getter for this field so that the implementation will perform an <a href="https://docs.mongodb.org/ecosystem/tutorial/mongoid-persistence/#atomic"><code>atomic increment</code></a> of the <code>next_bib</code> value in the database and return the result of <code>next_bib</code>. (<strong>Hint</strong>: use <code>[:key]</code> to access the current value of the attribute to avoid an infinite loop within <code>next_bib</code>.)</li>
</ul>
<p>You can demonstrate your new field and how to increment it using the rails console. The following demonstrates how the getter performs an atomic update on the <code>next_bib</code> field in the database and returns that value. This assures us that there will be only one use of a bib number as long as the state of that database field is not overwritten. For efficiency, no other state is involved in the database update. We control the amount of the increment, so bulk operations involving multiple <code>Entrants</code> could be efficiently implemented as well.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race=<span class="dt">Race</span>.create
&gt; race.next_bib
D {<span class="st">&quot;update&quot;</span>=&gt;<span class="st">&quot;races&quot;</span>, <span class="st">&quot;updates&quot;</span>=&gt;[{<span class="st">&quot;q&quot;</span>=&gt;{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56880945e301d009f0000042&#39;</span>)}, 
   <span class="st">&quot;u&quot;</span>=&gt;{<span class="st">&quot;$inc&quot;</span>=&gt;{<span class="st">&quot;next_bib&quot;</span>=&gt;<span class="dv">1</span>}}, <span class="st">&quot;multi&quot;</span>=&gt;<span class="dv">false</span>, <span class="st">&quot;upsert&quot;</span>=&gt;<span class="dv">false</span>}]...
 =&gt; <span class="dv">1</span> 
&gt; race.next_bib
D {<span class="st">&quot;update&quot;</span>=&gt;<span class="st">&quot;races&quot;</span>, <span class="st">&quot;updates&quot;</span>=&gt;[{<span class="st">&quot;q&quot;</span>=&gt;{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56880945e301d009f0000042&#39;</span>)}, 
   <span class="st">&quot;u&quot;</span>=&gt;{<span class="st">&quot;$inc&quot;</span>=&gt;{<span class="st">&quot;next_bib&quot;</span>=&gt;<span class="dv">1</span>}}, <span class="st">&quot;multi&quot;</span>=&gt;<span class="dv">false</span>, <span class="st">&quot;upsert&quot;</span>=&gt;<span class="dv">false</span>}]...
 =&gt; <span class="dv">2</span> </code></pre>
<p>The following shows accessing the current value of <code>next_bib</code> without calling the custom getter and changing the value.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race[<span class="st">:next_bib</span>]
 =&gt; <span class="dv">2</span> 
&gt; race[<span class="st">:next_bib</span>]
 =&gt; <span class="dv">2</span> </code></pre>
<pre class="shell"><code>$ rspec spec/service_facade_spec.rb -e rq01</code></pre></li>
<li><p>Implement a <code>get_group</code> instance method within the <code>Race</code> class that will return a <code>Placing</code> instance with its name set to the name of the age group the racer will be competing in. The method must:</p>
<ul>
<li>determine the age of the racer on January 01, of the year of the race</li>
<li>place the racer in a group that is rounded down to the nearest 10s and rounded up to the nearest 9s. Example: 26 would be <code>20 to 29</code>.</li>
<li>the cut-off for masters is 60 (e.g., 59 is <code>50..59</code> and 60 is <code>masters</code>)</li>
<li><p>groups have the following text formats</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="st">&quot;</span><span class="ot">#{</span>min_age<span class="ot">}</span><span class="st"> to </span><span class="ot">#{</span>max_age<span class="ot">}</span><span class="st"> (</span><span class="ot">#{</span>gender<span class="ot">}</span><span class="st">)&quot;</span>
<span class="st">&quot;masters </span><span class="ot">#{</span>gender<span class="ot">}</span><span class="st">&quot;</span></code></pre></li>
</ul>
<p><strong>Hint</strong>: Consider using the following. It is written to use demongoize so that it does not mandate a specific initialize method.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> get_group racer
  <span class="kw">if</span> racer &amp;&amp; racer.birth_year &amp;&amp; racer.gender
    quotient=(date.year-racer.birth_year)/<span class="dv">10</span>
    min_age=quotient*<span class="dv">10</span>
    max_age=((quotient<span class="dv">+1</span>)*<span class="dv">10</span>)-<span class="dv">1</span>
    gender=racer.gender
    name=min_age &gt;= <span class="dv">60</span> ? <span class="st">&quot;masters </span><span class="ot">#{</span>gender<span class="ot">}</span><span class="st">&quot;</span> : <span class="st">&quot;</span><span class="ot">#{</span>min_age<span class="ot">}</span><span class="st"> to </span><span class="ot">#{</span>max_age<span class="ot">}</span><span class="st"> (</span><span class="ot">#{</span>gender<span class="ot">}</span><span class="st">)&quot;</span>
    <span class="dt">Placing</span>.demongoize(<span class="st">:name=</span>&gt;name)
  <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<p>You can demonstrate your instance method using the rails console. The following calculates a group for a race in 2010 and racer birth years incremented by 10.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; pp (<span class="dv">1943</span>..<span class="dv">2003</span>).step(<span class="dv">10</span>).map {|yr| \
  <span class="dt">Race</span>.new(<span class="st">:date=</span>&gt;<span class="dt">Date</span>.new(<span class="dv">2010</span>)).get_group(<span class="dt">Racer</span>.new(<span class="st">:gender=</span>&gt;<span class="st">&quot;M&quot;</span>, <span class="st">:birth_year=</span>&gt;yr)).name}
[<span class="st">&quot;masters M&quot;</span>,
 <span class="st">&quot;50 to 59 (M)&quot;</span>,
 <span class="st">&quot;40 to 49 (M)&quot;</span>,
 <span class="st">&quot;30 to 39 (M)&quot;</span>,
 <span class="st">&quot;20 to 29 (M)&quot;</span>,
 <span class="st">&quot;10 to 19 (M)&quot;</span>,
 <span class="st">&quot;0 to 9 (M)&quot;</span>]</code></pre>
<pre class="shell"><code>$ rspec spec/service_facade_spec.rb -e rq02</code></pre></li>
<li><p>Implement <code>create_entrant</code> instance method in the <code>Race</code> class that will create a new <code>Entrant</code> for the <code>Race</code> for a supplied <code>Racer</code>. This method will update two collections; <code>races</code> and <code>results</code>. <code>races</code> will have the <code>next_bib</code> number of a <code>Race</code> document updated and <code>results</code> will have a new <code>Entrant</code> document inserted with information cloned from both <code>Race</code> and <code>Racer</code>.<br />This method must:</p>
<ul>
<li>build a new <code>Entrant</code> (<strong>Hint</strong>: <code>Entrant.new</code>)</li>
<li>clone the relevant <code>Race</code> information within <code>Entrant.race</code> (<strong>Hint</strong>: <code>race.attributes.symbolize_keys.slice(:_id, :n, :date)</code>)</li>
<li>clone the <code>RacerInfo</code> attributes within <code>Entrant.racer</code> (<strong>Hint</strong>: <code>race.info.attributes</code>)</li>
<li>determine the group for the racer and assign it to the entrant (<strong>Hint</strong>: <code>racer.get_group</code>)</li>
<li>create an <code>Entrant</code> result for every <code>Race</code> event (<strong>Hint</strong>: <code>entrant.send(&quot;#{event.name}=&quot;, event)</code>)</li>
<li>validate the <code>Entrant</code> (<strong>Hint</strong>: <code>entrant.validate</code>)</li>
<li>if valid, assign a new unique <code>bib</code> number from the database using an <code>atomic increment</code> and save to the database. (<strong>Hint</strong>: <code>next_bib</code>)</li>
<li>return the <code>Entrant</code></li>
</ul>
<p>If the <code>Entrant</code> was valid, it will be successfully stored in the database and the <code>next_bib</code> will be incremented for the <code>Race</code>. If the <code>Entrant</code> is invalid, the <code>Entrant</code> will not be stored, the <code>next_bib</code> will not be modified, and the returned object will have the validation information informing the caller of the errors.</p>
<p>You can demonstrate your new method for creating <code>Entrants</code> using the rails console. The following is an example of an invalid registration. An empty <code>Racer</code> is provided, the entrant is invalid, and not saved to the database. In addition to not being saved, the <code>next_bib</code> for the <code>Race</code> has not been modified and the returned object(s) have the associated validation error information.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race=<span class="dt">Race</span>.new
&gt; race[<span class="st">:next_bib</span>]
 =&gt; <span class="dv">0</span> 
&gt; entrant=race.create_entrant <span class="dt">Racer</span>.new
&gt; entrant.valid?
 =&gt; <span class="dv">false</span> 
&gt; entrant.persisted?
 =&gt; <span class="dv">false</span> 
&gt; race[<span class="st">:next_bib</span>]
 =&gt; <span class="dv">0</span> 
&gt; entrant.errors.messages
 =&gt; {<span class="st">:racer=</span>&gt;[<span class="st">&quot;is invalid&quot;</span>]} 
&gt; pp entrant.racer.errors.messages
{<span class="st">:first_name=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>],
 <span class="st">:last_name=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>],
 <span class="st">:gender=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>, <span class="st">&quot;must be M or F&quot;</span>],
 <span class="st">:birth_year=</span>&gt;[<span class="st">&quot;can&#39;t be blank&quot;</span>, <span class="st">&quot;must in past&quot;</span>]}</code></pre>
<p>The following is an example of a successful registration. We start off creating a default <code>Race</code> and locating a <code>Race</code> from the database we know was valid (you can create new ones if required). To start fresh, the existing <code>Racer</code> is cleared of any previous <code>Entrant</code> state and re-queried for. The re-query is needed because we have a non-standard relationship defined to a foreign key in an embedded class (<code>Entrant.racer</code>). Mongoid is not able to full clear the in-memory representation following the delete without getting a new copy from the database.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race=<span class="dt">Race</span>.default; race.name=<span class="st">&quot;A Race&quot;</span>; race.date=<span class="dt">Date</span>.current; race.save
&gt; racer=<span class="dt">Racer</span>.where(:<span class="st">&quot;info.fn&quot;</span>=&gt;<span class="st">&quot;cat&quot;</span>, :<span class="st">&quot;info.ln&quot;</span>=&gt;<span class="st">&quot;inhat&quot;</span>).first
&gt; racer.races.each {|r| r.delete }
&gt; racer=<span class="dt">Racer</span>.find(racer.id)</code></pre>
<p>We have no relationships at this point and the <code>next_bib</code> is set to 0.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; racer.races.count
 =&gt; <span class="dv">0</span>
&gt; race.entrants.count
 =&gt; <span class="dv">0</span> 
&gt; race[<span class="st">:next_bib</span>]
 =&gt; <span class="dv">0</span> </code></pre>
<p>When we create the valid entrant, an atomic update is issued to the database to increment the <code>next_bib</code> of the <code>Race</code> and the <code>Entrant</code> is inserted. <strong>Note</strong> that the relevant information from the <code>Race</code> and <code>Racer</code> are cloned and embedded within the <code>Entrant</code> for efficient access to this associated information when accessing the <code>Entrant</code>.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; entrant=race.create_entrant racer
<span class="dt">Overwriting</span> existing field _id <span class="kw">in</span> <span class="kw">class</span> <span class="dt">RacerInfo</span>.
D | {<span class="st">&quot;insert&quot;</span>=&gt;<span class="st">&quot;results&quot;</span>, <span class="st">&quot;documents&quot;</span>=&gt;[{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56a6be93e301d019a000003d&#39;</span>), 
     <span class="st">&quot;secs&quot;</span>=&gt;<span class="fl">0.0</span>, <span class="st">&quot;group&quot;</span>=&gt;{<span class="st">:name=</span>&gt;<span class="st">&quot;masters M&quot;</span>}, <span class="st">&quot;bib&quot;</span>=&gt;<span class="dv">1</span>, 
     <span class="st">&quot;updated_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-26</span> <span class="dv">00</span>:<span class="dv">32</span>:<span class="dv">19</span> <span class="dt">UTC</span>, <span class="st">&quot;created_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-26</span> <span class="dv">00</span>:<span class="dv">32</span>:<span class="dv">19</span> <span class="dt">UTC</span>, 
     <span class="st">&quot;race&quot;</span>=&gt;{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(...
&gt; entrant.persisted?
 =&gt; <span class="dv">true</span> 
&gt; entrant.valid?
 =&gt; <span class="dv">true</span> 
&gt; entrant.bib
 =&gt; <span class="dv">1</span> 
&gt; race[<span class="st">:next_bib</span>]
 =&gt; <span class="dv">1</span> 
&gt; entrant.results.pluck(:<span class="st">&quot;event.n&quot;</span>)
 =&gt; [<span class="st">&quot;swim&quot;</span>, <span class="st">&quot;t1&quot;</span>, <span class="st">&quot;bike&quot;</span>, <span class="st">&quot;t2&quot;</span>, <span class="st">&quot;run&quot;</span>] 
&gt; entrant.race_name
 =&gt; <span class="st">&quot;A Race&quot;</span> 
&gt; entrant.last_name
 =&gt; <span class="st">&quot;inhat&quot;</span> 
&gt; entrant.city
 =&gt; <span class="st">&quot;Oakland&quot;</span> 
&gt; entrant.swim.event.distance
 =&gt; <span class="fl">1.0</span> </code></pre>
<p>If we refresh the state of our parent collections (because of the embedded foreign keys) and list their contents, they will show the relevant <code>Entrant</code> information.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race=<span class="dt">Race</span>.find(race.id)
&gt; race.entrants.each {|r| p <span class="st">&quot;</span><span class="ot">#{</span>r.bib<span class="ot">}</span><span class="st">, </span><span class="ot">#{</span>r.racer.first_name<span class="ot">}</span><span class="st">, </span><span class="ot">#{</span>r.racer.last_name<span class="ot">}</span><span class="st">&quot;</span>}
<span class="st">&quot;1, cat, inhat&quot;</span>

&gt; racer=<span class="dt">Racer</span>.find(racer.id)
&gt; racer.races.each {|r| p <span class="st">&quot;</span><span class="ot">#{</span>r.race.name<span class="ot">}</span><span class="st">, </span><span class="ot">#{</span>r.race.date<span class="ot">}</span><span class="st">, </span><span class="ot">#{</span>r.bib<span class="ot">}</span><span class="st">&quot;</span>}
<span class="st">&quot;A Race, 2016-01-26, 1&quot;</span></code></pre>
<pre class="shell"><code>$ rspec spec/service_facade_spec.rb -e rq03</code></pre></li>
<li><p>Implement a <a href="https://docs.mongodb.org/ecosystem/tutorial/mongoid-queries/#named-scopes"><code>named scope</code></a> in the <code>Entrant</code> class called by <code>upcoming</code> and <code>past</code> that returns a chainable criteria for Entrants that have not completed and have occured in the past. These scopes must:</p>
<ul>
<li><p>return a chainable Mongoid query criteria set to return matching <code>Entrant</code> documents based on the <code>:race.date</code> property</p></li>
<li><code>upcoming</code> races have dates greater than or equal to today's date</li>
<li><p><code>past</code> races have dates less than today's date</p></li>
</ul>
<p>You can use the Rails console to demonstrate your new named scopes. In the example below we create three (3) races (in the past, present, and future) and use the method we just implemented to create an entrant in each of them.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race1=<span class="dt">Race</span>.create(<span class="st">:name=</span>&gt;<span class="st">&quot;Yesterday&#39;s Entrant&quot;</span>,<span class="st">:date=</span>&gt;<span class="dt">Date</span>.yesterday) 
&gt; race2=<span class="dt">Race</span>.create(<span class="st">:name=</span>&gt;<span class="st">&quot;Today&#39;s Entrant&quot;</span>,<span class="st">:date=</span>&gt;<span class="dt">Date</span>.today)              
&gt; race3=<span class="dt">Race</span>.create(<span class="st">:name=</span>&gt;<span class="st">&quot;Tomorrow&#39;s Entrant&quot;</span>,<span class="st">:date=</span>&gt;<span class="dt">Date</span>.tomorrow)    
&gt; racer=<span class="dt">Racer</span>.create(<span class="st">:first_name=</span>&gt;<span class="st">&quot;thing&quot;</span>,<span class="st">:last_name=</span>&gt;<span class="st">&quot;two&quot;</span>,<span class="st">:gender=</span>&gt;<span class="st">&quot;M&quot;</span>,<span class="st">:birth_year=</span>&gt;<span class="dv">1960</span>)              
&gt; race1.create_entrant(racer)
&gt; race2.create_entrant(racer)
&gt; race3.create_entrant(racer)</code></pre>
<p>When we use the <code>past</code> scope we get a criteria looking for <code>Entrant</code> documents in the past. When we add a <code>where()</code> clause to that, the two are combined. One interesting thing to note is that the criteria for the embedded document is being passed raw to the MongoDB driver -- so we must use the physical key names in the database and not the logical attribute names in the embedded model class.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; pp <span class="dt">Entrant</span>.past.where(:<span class="st">&quot;race.n&quot;</span>=&gt;{<span class="st">:$regex=</span>&gt;<span class="st">&quot;Entrant&quot;</span>}).first.attributes                               
D | {<span class="st">&quot;find&quot;</span>=&gt;<span class="st">&quot;results&quot;</span>, <span class="st">&quot;filter&quot;</span>=&gt;{<span class="st">&quot;race.date&quot;</span>=&gt;{<span class="st">&quot;$lt&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-15</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>}, <span class="st">&quot;race.n&quot;</span>=&gt;{<span class="st">:$regex=</span>&gt;<span class="st">&quot;Entrant&quot;</span>}}}
{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56990913e301d03300000019&#39;</span>),
 <span class="st">&quot;bib&quot;</span>=&gt;<span class="dv">1</span>,
 <span class="st">&quot;updated_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-15</span> <span class="dv">14</span>:<span class="dv">58</span>:<span class="dv">27</span> <span class="dt">UTC</span>,
 <span class="st">&quot;created_at&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-15</span> <span class="dv">14</span>:<span class="dv">58</span>:<span class="dv">27</span> <span class="dt">UTC</span>,
 <span class="st">&quot;race&quot;</span>=&gt;
  {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;569908c9e301d03300000015&#39;</span>),
   <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;Yesterday&#39;s Entrant&quot;</span>,
   <span class="st">&quot;date&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-14</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>},
 <span class="st">&quot;racer&quot;</span>=&gt;
  {<span class="st">&quot;fn&quot;</span>=&gt;<span class="st">&quot;thing&quot;</span>,
   <span class="st">&quot;ln&quot;</span>=&gt;<span class="st">&quot;two&quot;</span>,
   <span class="st">&quot;g&quot;</span>=&gt;<span class="st">&quot;M&quot;</span>,
   <span class="st">&quot;yr&quot;</span>=&gt;<span class="dv">1960</span>,
   <span class="st">&quot;racer_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56990905e301d03300000018&#39;</span>),
   <span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56990905e301d03300000018&#39;</span>)}}</code></pre>
<p>Notice we can use the scope on relationships. In the following example, we can locate upcoming races the racer is registered for and add <code>pluck</code> to get the information we need. In practice, it was found best to avoid getting too agressive with fine-grain plucks into sub-documents.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; pp racer.races.upcoming.pluck(<span class="st">:race</span>)
D | {<span class="st">&quot;find&quot;</span>=&gt;<span class="st">&quot;results&quot;</span>, <span class="st">&quot;filter&quot;</span>=&gt;{<span class="st">&quot;racer.racer_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56990905e301d03300000018&#39;</span>), 
                                   <span class="st">&quot;race.date&quot;</span>=&gt;{<span class="st">&quot;$gte&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-15</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>}}, 
                                   <span class="st">&quot;projection&quot;</span>=&gt;{<span class="st">&quot;race&quot;</span>=&gt;<span class="dv">1</span>}, <span class="st">&quot;sort&quot;</span>=&gt;{<span class="st">&quot;race.date&quot;</span>=&gt;-<span class="dv">1</span>}}
[{<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;569908eee301d03300000017&#39;</span>),
  <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;Tomorrow&#39;s Entrant&quot;</span>,
  <span class="st">&quot;date&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-16</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>},
 {<span class="st">&quot;_id&quot;</span>=&gt;<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;569908dfe301d03300000016&#39;</span>),
  <span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;Today&#39;s Entrant&quot;</span>,
  <span class="st">&quot;date&quot;</span>=&gt;<span class="dv">2016</span><span class="bn">-01</span><span class="dv">-15</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>}]</code></pre>
<pre class="shell"><code>$ rspec spec/service_facade_spec.rb -e rq04</code></pre></li>
<li><p>Implement <code>upcoming_available_to</code> class method in the <code>Race</code> class that will return a criteria result representing all the <code>upcoming</code> <code>Race</code>s that the <code>Racer</code> has not yet registered for. This method must:</p>
<ul>
<li>be a class method in <code>Racer</code> called <code>upcoming_available_to</code></li>
<li>accept a <code>Racer</code> as an input parameter</li>
<li>return a criteria result which the caller can add additional query, page, and pluck commands to.</li>
</ul>
<p><strong>Hint</strong>: The following query will return an array of upcoming race_ids for the racer. The query returns a MongoDB hash and the <code>map</code> extracts the <code>_id</code> value from the hash. The result is an array of <code>race_ids</code>.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; upcoming_race_ids=racer.races.upcoming.pluck(<span class="st">:race</span>).map {|r| r[<span class="st">:_id</span>]}
 =&gt; [<span class="dt">BSON</span>::<span class="dt">ObjectId</span>(<span class="st">&#39;56991aa3e301d0330000002b&#39;</span>)]</code></pre>
<p><strong>Hint</strong>: The following query (on the second line) will return race information for races that match a set of IDs. <strong>NOTE</strong> Prior to invoking this block of code, please see the example further ahead, where the following races are created:</p>
<ul>
<li>&quot;Missed it A2&quot;</li>
<li>&quot;Going There A2&quot;</li>
<li>&quot;Thinking About It A2&quot;</li>
</ul>
<p>These races first need to be populated in the database to demonstrate this block of code.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race_ids=<span class="dt">Race</span>.where(<span class="st">:name=</span>&gt;{<span class="st">:$regex=</span>&gt;<span class="st">&quot;A2$&quot;</span>}).map {|r| r.id}
&gt; pp <span class="dt">Race</span>.in(<span class="st">:id=</span>&gt;race_ids).pluck(<span class="st">:name</span>, <span class="st">:date</span>)
[[<span class="st">&quot;Missed it A2&quot;</span>, <span class="dv">2016</span><span class="bn">-01</span><span class="dv">-14</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>],
 [<span class="st">&quot;Going There A2&quot;</span>, <span class="dv">2016</span><span class="bn">-01</span><span class="dv">-16</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>],
 [<span class="st">&quot;Thinking About It A2&quot;</span>, <span class="dv">2016</span><span class="bn">-02</span><span class="dv">-15</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>]]</code></pre>
<p><strong>Hint</strong>: The following scope will return races on or after today no matter who is registered for them.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">Race</span>.upcoming.where(<span class="st">:name=</span>&gt;{<span class="st">:$regex=</span>&gt;<span class="st">&quot;A2&quot;</span>}).pluck(<span class="st">:name</span>,<span class="st">:date</span>)
 [[<span class="st">&quot;Going There A2&quot;</span>, <span class="dv">2016</span><span class="bn">-01</span><span class="dv">-16</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>],
  [<span class="st">&quot;Thinking About It A2&quot;</span>, <span class="dv">2016</span><span class="bn">-02</span><span class="dv">-15</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>]]</code></pre>
<p><strong>Hint</strong>: This method must return complete <code>Race</code> instances being held on or after today that are not in a list of race_ids for the racer.</p>
<p>You can demonstrate your new method using the rails console. In the following example we create three (3) races:</p>
<ul>
<li>one in the past that we did not sign up for</li>
<li>one in the future that we have signed up for</li>
<li>one in the future that we have not yet signed up for</li>
</ul>
<p>Notice that when we create (<code>Entrant</code>) registrations in the database the in-memory <code>Racer</code> instance must be refreshed. Mongoid will continue to use what it may have last queried for.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; race1=<span class="dt">Race</span>.create(<span class="st">:name=</span>&gt;<span class="st">&quot;Missed it A2&quot;</span>,<span class="st">:date=</span>&gt;<span class="dt">Date</span>.yesterday)
&gt; race2=<span class="dt">Race</span>.create(<span class="st">:name=</span>&gt;<span class="st">&quot;Going There A2&quot;</span>,<span class="st">:date=</span>&gt;<span class="dt">Date</span>.tomorrow)
&gt; race2.create_entrant racer
&gt; race3=<span class="dt">Race</span>.create(<span class="st">:name=</span>&gt;<span class="st">&quot;Thinking About It A2&quot;</span>,<span class="st">:date=</span>&gt;<span class="dt">Date</span>.current<span class="dv">+1</span>.month)
&gt; <span class="dt">Racer</span>.find(racer.id).races.pluck(:<span class="st">&quot;race.n&quot;</span>)
 =&gt; [{<span class="st">&quot;n&quot;</span>=&gt;<span class="st">&quot;Going There A2&quot;</span>}] </code></pre>
<p>Given two races that the racer has not registered for and only one of them in the future, the method should return only the one future race.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">Date</span>.current
 =&gt; <span class="dt">Fri</span>, <span class="dv">15</span> <span class="dt">Jan</span> <span class="dv">2016</span>
&gt; <span class="dt">Race</span>.upcoming_available_to(racer).where(<span class="st">:name=</span>&gt;{<span class="st">:$regex=</span>&gt;<span class="st">&quot;A2&quot;</span>}).pluck(<span class="st">:name</span>,<span class="st">:date</span>)
 =&gt; [[<span class="st">&quot;Thinking About It A2&quot;</span>, <span class="dv">2016</span><span class="bn">-02</span><span class="dv">-15</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>]]</code></pre>
<p>Given the same set of races and registrations and your method, you can optionally find out which races the racer did not register for.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">&gt; <span class="dt">Date</span>.current
 =&gt; <span class="dt">Fri</span>, <span class="dv">15</span> <span class="dt">Jan</span> <span class="dv">2016</span>
&gt; <span class="dt">Race</span>.not.upcoming_available_to(racer).where(<span class="st">:name=</span>&gt;{<span class="st">:$regex=</span>&gt;<span class="st">&quot;A2&quot;</span>}).pluck(<span class="st">:name</span>,<span class="st">:date</span>)
 =&gt; [[<span class="st">&quot;Missed it A2&quot;</span>, <span class="dv">2016</span><span class="bn">-01</span><span class="dv">-14</span> <span class="dv">00</span>:<span class="dv">00</span>:<span class="dv">00</span> <span class="dt">UTC</span>]]</code></pre>
<pre class="shell"><code>$ rspec spec/service_facade_spec.rb -e rq05</code></pre></li>
</ol>
<h3 id="web-raceracer-resource-access">Web Race/Racer Resource Access</h3>
<p>This section concentrates on providing web access to root-level <code>Racer</code> and <code>Race</code> resources and implementing some navigation between them. At the end of this section you will be able to visualize the ingested data within the database and be able to create, edit, and delete some new and existing <code>Racer</code> and <code>Race</code> resources using web pages.</p>
<p>Although the web tier is not officially part of this module, the primary reason for building the data tier and building it with Mongoid is to provide users access to the data. By going through the implementation of a web tier, you will gain additional insight into why certain features exist within Mongoid and where they can be used. To keep this manageable, much of the web tier is provided to you in complete or near-complete hints with only portions of the data tier access removed for you to fill in.</p>
<p>If your database is riddled with half-baked documents from the previous sections -- now would be a good time to clean it up before accessing from the view. Some short-cuts where taken with validation checks during earlier sections to try to get to this point incrementally but as quickly as possible. Race events like &quot;foo&quot; and &quot;bar123&quot; won't make the end-to-end application all too happy.</p>
<ol style="list-style-type: decimal">
<li><p>Implement rails scaffold for <code>Racer</code>. Use the <code>index</code> to show a list of racers and allow navigation to pages to create new, and delete or edit existing racers. The user should be able to supply:</p>
<ul>
<li><code>first_name</code> : String</li>
<li><code>last_name</code> : String</li>
<li><code>gender</code> (&quot;M&quot; or &quot;F&quot;) : String</li>
<li><code>birth_year</code> : Integer</li>
<li>(residence) <code>city</code> : String</li>
<li>(residence) <code>state</code> : String</li>
</ul>
<p><strong>Hint</strong>: Use <code>rails g scaffold_controller</code> to generate the controller and view pages.</p>
<pre class="shell"><code>$ rails g scaffold_controller Racer first_name last_name gender birth_year:Integer city state</code></pre>
<p>Remember to update the <code>config/routes.rb</code></p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">Rails</span>.application.routes.draw <span class="kw">do</span>
  resources <span class="st">:racers</span></code></pre>
<p>You can demonstrate your <code>Racer</code> registration and CRUD using the <a href="http://localhost:3000/racers"><code>http://localhost:3000/racers</code></a> URL after you have started your Rails server. With the test data loaded (see &quot;Getting Started&quot;), you should see a full set of Racers on this page.</p>
<pre class="shell"><code>$ rails s
http://localhost:3000/racers</code></pre>
<p>Verify the web commands are working with your data model</p>
<ul>
<li>show - view details of specific Racer</li>
<li>edit - edit details of specific Racer</li>
<li>delete - remove a specific Racer</li>
<li>new - (all the way at the bottom) - create a new Racer</li>
</ul>
<p>It would also be useful to inspect the code within the view classes and controller to see how they integrated with your <code>Racer</code> model. For example, the code snippet from a views page shows the results of the attribute flattening being used. Without that work, we would have had to edit this file to access <code>racer.info.residence.city</code> and have to account for nils along the way (yuk!).</p>
<pre class="sourceCode html"><code class="sourceCode html"># app/views/racers/index.html.erb
<span class="er">&lt;</span>% @racers.each do |racer| %&gt;
  <span class="kw">&lt;tr&gt;</span>
    <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= racer.first_name %&gt;<span class="kw">&lt;/td&gt;</span>
    <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= racer.last_name %&gt;<span class="kw">&lt;/td&gt;</span>
    <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= racer.gender %&gt;<span class="kw">&lt;/td&gt;</span>
    <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= racer.birth_year %&gt;<span class="kw">&lt;/td&gt;</span>
    <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= racer.city %&gt;<span class="kw">&lt;/td&gt;</span>
    <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= racer.state %&gt;<span class="kw">&lt;/td&gt;</span></code></pre>
<div class="figure">
<img src="docs/rsz_listing_racers.png" alt="List Racers" /><p class="caption">List Racers</p>
</div>
<p><a href="docs/rsz_listing_racers.png">List Racers</a></p>
<pre class="shell"><code>$ rspec spec/web_resources_spec.rb -e rq01</code></pre></li>
<li><p>Implement rails scaffold for <code>Races</code>. Use the <code>index</code> page to show a list of all races in descending date order. Use the remaining controls within the scaffold to be able to create new and delete or edit existing races.</p>
<ul>
<li><code>name</code> : String</li>
<li><code>date</code> : Date</li>
<li><code>city</code> : String</li>
<li><code>state</code> : String</li>
<li><code>swim_distance</code> : Float</li>
<li><code>swim_units</code> : String</li>
<li><code>bike_distance</code> : Float</li>
<li><code>bike_units</code> : String</li>
<li><code>run_distance</code> : Float</li>
<li><code>run_units</code> : String</li>
</ul>
<p><strong>Hint</strong>: Use <code>rails g scaffold_controller</code> to generate the controller and view pages.</p>
<pre class="shell"><code>rails g scaffold_controller Race name date:Date city state swim_distance:Float swim_units \
    bike_distance:Float bike_units: run_distance:Float run_units</code></pre>
<p><strong>Hint</strong>: Remember to update the <code>config/routes.rb</code></p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">Rails</span>.application.routes.draw <span class="kw">do</span>
  ... 
  resources <span class="st">:races</span></code></pre>
<p><strong>Hint</strong>: Remember to adjust the query in the controller (<code>app/controllers/races_controller.rb#index</code>) to provide the required sort order.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="kw">def</span> index
  <span class="ot">@races</span> = <span class="dt">Race</span>.all.order_by(...
<span class="kw">end</span></code></pre>
<p>You should have the following URIs, actions, and helper methods in your application at this point. We can add the suffix <code>_path</code> to the listed helper method prefix as a short-cut to expressing the URI and method to reach the <code>controller#action</code> and resulting view. As there is a key helper method we will reference later from the <code>racers#show</code> and <code>racers#edit</code> pages.</p>
<ul>
<li><code>race_path(@race)</code> - used to navigate to individual race results</li>
</ul>
<pre class="shell"><code>$ rake routes | grep races
        races GET    /races(.:format)                    races#index
              POST   /races(.:format)                    races#create
     new_race GET    /races/new(.:format)                races#new
    edit_race GET    /races/:id/edit(.:format)           races#edit
         race GET    /races/:id(.:format)                races#show
              PATCH  /races/:id(.:format)                races#update
              PUT    /races/:id(.:format)                races#update
              DELETE /races/:id(.:format)                races#destroy</code></pre>
<p>You can demonstrate your <code>Race</code> registration and CRUD using the <a href="http://localhost:3000/races"><code>http://localhost:3000/races</code></a> URL. (fyi...that would equate to the <code>races_path</code> helper method shown above)</p>
<p>It would be helpful to inspect the controller and view files to see how the scaffold was layered onto your data mode. For example, the following snippet shows a look at a <code>partial</code> and how it leverages the convenience methods to access the swim properties of a race. This would have been much tougher to implement had the data tier not built a facade for ease of data access.</p>
<pre class="sourceCode html"><code class="sourceCode html"># app/views/races/_form.html.erb
<span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;field&quot;</span><span class="kw">&gt;</span>
  <span class="er">&lt;</span>%= f.label :swim_distance %&gt;<span class="kw">&lt;br&gt;</span>
  <span class="er">&lt;</span>%= f.text_field :swim_distance %&gt;
<span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;field&quot;</span><span class="kw">&gt;</span>
  <span class="er">&lt;</span>%= f.label :swim_units %&gt;<span class="kw">&lt;br&gt;</span>
  <span class="er">&lt;</span>%= f.text_field :swim_units %&gt;
<span class="kw">&lt;/div&gt;</span></code></pre>
<div class="figure">
<img src="docs/rsz_listing_races.jpg" alt="List Races" /><p class="caption">List Races</p>
</div>
<p><a href="docs/rsz_listing_races.jpg">List Races</a></p>
<pre class="shell"><code>$ rspec spec/web_resources_spec.rb -e rq02</code></pre></li>
<li><p>Update the <code>races#show</code> controller and view to display a table of entrants and their results ordered by overall time (<code>ASCENDING</code>), last name (<code>ASCENDING</code>), and first name (<code>ASCENDING</code>). That way the results start out in alphabetical order and switch to time order once results are added. Your <code>races#show</code> controller action must:</p>
<ul>
<li>define an instance variable called <code>@entrants</code> that list all <code>Entrants</code> for the specific <code>Race</code></li>
<li>order the collection of <code>Entrants</code> to be by overall time (ascending), last name (ascending), and first name (ascending).</li>
</ul>
<p>Your <code>races#show</code> page must have a table with columns that match those indicated in the order given below:</p>
<ul>
<li>column with <code>Place</code> - <code>entrant.overall_place</code></li>
<li>column with <code>Time</code> - <code>entrant.secs</code> formatted as <code>H:MM:SS</code></li>
<li>column with <code>Name</code> - <code>entrant.last_name, entrant.first_name</code></li>
<li>column with <code>Bib#</code> - <code>entrant.bib</code></li>
<li>column with <code>City</code> - <code>entrant.city</code></li>
<li>column with <code>State</code> - <code>entrant.state</code></li>
<li>column with <code>Gender</code> - <code>entrant.racer_gender</code></li>
<li>column with <code>Gender Place</code> - <code>entrant.gender_place</code></li>
<li>column with <code>Group</code> - <code>entrant.group_name</code></li>
<li>column with <code>Group Place</code> - <code>entrant.group_place</code></li>
<li>column with <code>Swim</code> - <code>entrant.swim_secs</code> formated as <code>H:MM:SS</code></li>
<li>column with <code>Pace 100</code> - <code>entrant.swim_pace_100</code> formatted as <code>MM:HH</code></li>
<li>column with <code>T1</code> - <code>entrant.t1_secs</code> formatted as <code>MM:SS</code></li>
<li>column with <code>Bike</code> - <code>entrant.bike_secs</code> formated as <code>H:MM:SS</code></li>
<li>column with <code>MPH</code> - <code>entrant.bike_mph</code> format rounded to one (1) decimal place</li>
<li>column with <code>T2</code> - <code>entrant.t2_secs</code> formatted as <code>MM:SS</code></li>
<li>column with <code>Run</code> - <code>entrant.run_secs</code> formated as <code>H:MM:SS</code></li>
<li>column with <code>Min Mile</code> - <code>entrant.run_mmile</code> formatted as <code>MM:SS</code></li>
<li>link to the associated <code>Racer</code> - <code>entrant.racer.id</code> - around the <code>Name</code> element if they have not been deleted</li>
</ul>
<p><strong>Hint</strong>: Make your data access edits to the controller's show method. The <code>Race</code> will already have been located and assigned to the <code>@race</code> attribute by the <code>set_race</code> <code>before_action</code>. You must assign the collection of <code>Entrants</code> to the <code>@entrants</code> attribute. By assigning to an instance attribute -- you are making these properties available to the view. By forming and ordering the collection in the controller -- you are allowing the view to focus on the job of data display and not data access. In this specific case we need to query the <code>results</code> collection directly due to a limitation trying to sort a Mongoid collection that already has a default sort order defined for <code>Race.entrants</code>.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># app/controllers/races_controller.rb</span>
<span class="kw">def</span> show
  <span class="ot">@entrants</span>=<span class="dt">Entrant</span>.where(:<span class="st">&quot;race._id&quot;</span>=&gt;<span class="ot">@race</span>.id)....
<span class="kw">end</span>
<span class="kw">def</span> set_race
  <span class="ot">@race</span> = <span class="dt">Race</span>.find(params[<span class="st">:id</span>])
<span class="kw">end</span></code></pre>
<p><strong>Hint</strong>: For the view, you can define a helper method to format secs in to an H:MM:SS and MM:SS as well as round down the mph decimal places when displaying the data.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># triresults/app/helpers/application_helper.rb</span>
<span class="kw">module</span> <span class="dt">ApplicationHelper</span>
  <span class="kw">def</span> format_hours secs
    <span class="dt">Time</span>.at(secs).utc.strftime(<span class="st">&quot;%k:%M:%S&quot;</span>) <span class="kw">if</span> secs
  <span class="kw">end</span>
  <span class="kw">def</span> format_minutes secs
    <span class="dt">Time</span>.at(secs).utc.strftime(<span class="st">&quot;%M:%S&quot;</span>) <span class="kw">if</span> secs
  <span class="kw">end</span>
  <span class="kw">def</span> format_mph mph
    mph.round(<span class="dv">1</span>) <span class="kw">if</span> mph
  <span class="kw">end</span>
<span class="kw">end</span></code></pre>
<p><strong>Hint</strong>: You can start with the <code>racers#index</code> view and make the necessary changes from there.</p>
<ul>
<li><p>the link to the <code>racer#show</code> pages can be obtained using the <code>racer_path</code> helper method and passing in the <code>entrant.racer.id</code> of the entrant.</p></li>
<li><p>remember that the relationship from Racer to Entrant.race is set to <code>:nullify</code> if the racer is deleted from the database so entrant.race.id can be nil.</p></li>
</ul>
<pre class="sourceCode ruby"><code class="sourceCode ruby">has_many <span class="st">:races</span>, ... dependent: <span class="st">:nullify</span></code></pre>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># triresults/app/views/races/show.html.erb</span>
&lt;%= link_to <span class="st">&#39;Back&#39;</span>, races_path <span class="ot">%&gt;</span>
<span class="st">&lt;/p</span><span class="ot">&gt;</span>&lt;strong&gt;<span class="dt">Results</span>:&lt;<span class="ot">/strong&gt;</span>
<span class="ot">&lt;table&gt;</span>
<span class="ot">  &lt;thead&gt;</span>
<span class="ot">    &lt;tr&gt;</span>
<span class="ot">      &lt;th&gt;Place&lt;/</span>th&gt;
      &lt;th&gt;<span class="dt">Time</span>&lt;<span class="ot">/th&gt;</span>
<span class="ot">      &lt;th&gt;Name&lt;/</span>th&gt;
      ...
      &lt;th&gt;<span class="dt">Run</span>&lt;<span class="ot">/th&gt;</span>
<span class="ot">      &lt;th&gt;Min Mile&lt;/</span>th&gt;
      &lt;th colspan=<span class="st">&quot;3&quot;</span>&gt;&lt;<span class="ot">/th&gt;</span>
<span class="ot">    &lt;/</span>tr&gt;
  &lt;<span class="ot">/thead&gt;</span>

<span class="ot">  &lt;tbody&gt;</span>
<span class="ot">    &lt;% @entrants.each do |entrant| %&gt;</span>
<span class="ot">      &lt;tr&gt;</span>
<span class="ot">        &lt;td&gt;&lt;%= entrant.overall_place %&gt;&lt;/</span>td&gt;
        &lt;td&gt;&lt;%= format_hours entrant.secs <span class="ot">%&gt;</span><span class="st">&lt;/td</span><span class="ot">&gt;</span>
        &lt;% <span class="kw">if</span> entrant.racer.id <span class="ot">%&gt;</span>
<span class="st">          &lt;td</span><span class="ot">&gt;</span>&lt;%= link_to <span class="st">&quot;</span><span class="ot">#{</span>entrant.last_name<span class="ot">}</span><span class="st">, </span><span class="ot">#{</span>entrant.first_name<span class="ot">}</span><span class="st">&quot;</span>, racer_path(entrant.racer.id) %&gt;&lt;<span class="ot">/td&gt;</span>
<span class="ot">        &lt;% else %&gt;</span>
<span class="ot">          &lt;td&gt;&lt;%= &quot;#{</span>entrant.last_name<span class="ot">}, #{</span>entrant.first_name<span class="ot">}&quot; %&gt;&lt;/</span>td&gt;
        &lt;% <span class="kw">end</span><span class="ot"> %&gt;</span>
<span class="st">        ...</span>
<span class="st">        &lt;td</span><span class="ot">&gt;</span>&lt;%= format_hours entrant.run_secs <span class="ot">%&gt;</span><span class="st">&lt;/td</span><span class="ot">&gt;</span>
        &lt;td&gt;&lt;%= format_minutes entrant.run_mmile <span class="ot">%&gt;</span><span class="st">&lt;/td</span><span class="ot">&gt;</span>
      &lt;<span class="ot">/tr&gt;</span>
<span class="ot">    &lt;% end %&gt;</span>
<span class="ot">  &lt;/</span>tbody&gt;
&lt;<span class="ot">/table&gt;</span></code></pre>
<p>You should now be able to see a list of entrants for a race and be able to navigate to the show page for each entrant to see their more detailed results. If you navigate to a historical race, the results will be in ascending time order. If you navigate to an upcoming race without finish times -- the page will be ordered by last/first name ascending. You should be able to navigate from the result to the show page for the specific <code>Racer</code> using the link on name.</p>
<div class="figure">
<img src="docs/rsz_races_show.png" alt="Show Race Entrants" /><p class="caption">Show Race Entrants</p>
</div>
<p><a href="docs/rsz_races_show.png">Show Race Entrants</a></p>
<pre class="shell"><code>$ rspec spec/web_resources_spec.rb -e rq03</code></pre></li>
<li><p>Update the <code>racers#show</code> view to display a table of all races the racer has registered for in descending time order. Your <code>racers#show</code> controller action must:</p>
<ul>
<li>define an instance variable called <span class="citation">@races</span> that list all <code>Entrants</code> for the specific <code>Racer</code></li>
<li>order the collection of <code>Entrants</code> to be by race date (descending) (<strong>Hint</strong>: this is the default sort order for the racer.races collection)</li>
</ul>
<p>Your <code>racers#show</code> page should have a table with:</p>
<ul>
<li>column with <code>Name</code> - <code>entry.race_name</code></li>
<li>column with <code>Date</code> - <code>entry.race_date</code></li>
<li>column with <code>Overall</code> - <code>entry.overall.place</code></li>
<li>column with <code>Gender</code> - <code>entry.gender.place</code></li>
<li>column with <code>Group</code> - <code>entry.group.place</code></li>
<li>link to <code>Results</code> - <code>race_path(race)</code></li>
</ul>
<p><strong>Hint</strong>: You can use the controller show method to define the collection of <code>Entrants</code> for <code>Races</code> to display. This collection is ordered, by default, in descending time order.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby">  <span class="kw">def</span> show
    <span class="ot">@races</span>=<span class="ot">@racer</span>.races
  <span class="kw">end</span></code></pre>
<p><strong>Hint</strong>: You can start with a copy of the table from the <code>races#show</code> view (<code>app/views/races/index.html.erb</code>) and make changes from there.</p>
<pre class="sourceCode html"><code class="sourceCode html"># app/views/racers/show.html.erb
<span class="er">&lt;</span>%= link_to &#39;Back&#39;, racers_path %&gt;
<span class="kw">&lt;/p&gt;</span>
<span class="kw">&lt;strong&gt;</span>Races:<span class="kw">&lt;/strong&gt;</span>
<span class="kw">&lt;table&gt;</span>
  <span class="kw">&lt;thead&gt;</span>
    <span class="kw">&lt;tr&gt;</span>
      <span class="kw">&lt;th&gt;</span>Name<span class="kw">&lt;/th&gt;</span>
      <span class="kw">&lt;th&gt;</span>Date<span class="kw">&lt;/th&gt;</span>
      ...
      <span class="kw">&lt;th&gt;</span>Overall Place<span class="kw">&lt;/th&gt;</span>
      <span class="kw">&lt;th&gt;</span>Gender Place<span class="kw">&lt;/th&gt;</span>
      <span class="kw">&lt;th&gt;</span>Group Place<span class="kw">&lt;/th&gt;</span>
      <span class="kw">&lt;th</span><span class="ot"> colspan=</span><span class="st">&quot;3&quot;</span><span class="kw">&gt;&lt;/th&gt;</span>
    <span class="kw">&lt;/tr&gt;</span>
  <span class="kw">&lt;/thead&gt;</span>

  <span class="kw">&lt;tbody&gt;</span>
    <span class="er">&lt;</span>% @racer.races.each do |entry| %&gt;
      <span class="kw">&lt;tr&gt;</span>
        <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= entry.race_name %&gt;<span class="kw">&lt;/td&gt;</span>
        <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= entry.race_date %&gt;<span class="kw">&lt;/td&gt;</span>
        ...
        <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= entry.overall_place %&gt;<span class="kw">&lt;/td&gt;</span>
        <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= entry.gender_place %&gt;<span class="kw">&lt;/td&gt;</span>
        <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= entry.group_place %&gt;<span class="kw">&lt;/td&gt;</span>
        <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= link_to &#39;Results&#39;, race_path(entry.race) %&gt;<span class="kw">&lt;/td&gt;</span>
      <span class="kw">&lt;/tr&gt;</span>
    <span class="er">&lt;</span>% end %&gt;
  <span class="kw">&lt;/tbody&gt;</span>
<span class="kw">&lt;table&gt;</span></code></pre>
<p>At this point, you should be able to see the races that the specific racer has registered for, ordered in date descending order with race results. Historical results will have placings. Upcoming races will not. You should be able to navigate from the result to the show page for the specific <code>Race</code> using the <code>Results</code> link.</p>
<div class="figure">
<img src="docs/rsz_show_racer_results.png" alt="Racer Race Results" /><p class="caption">Racer Race Results</p>
</div>
<p><a href="docs/rsz_show_racer_results.png">Racer Race Results</a></p>
<pre class="shell"><code>$ rspec spec/web_resources_spec.rb -e rq04</code></pre></li>
<li><p>Update the <code>racers#edit</code> action and resulting view (a partial) to display a table of available upcoming races the racer has not already registered for. The controller action for <code>racers#edit</code> must:</p>
<ul>
<li>obtain a collection to the upcoming races the <code>Racer</code> has not registered for</li>
<li>order the collection in time order, descending</li>
</ul>
<p>The view for <code>racers#edit</code> must display a table with the following data in the following following order when the <code>Racer</code> is persisted and the partial is being used for edit mode:</p>
<ul>
<li>column with <code>Name</code> - <code>race.name</code></li>
<li>column with <code>Date</code> - <code>race.date</code></li>
<li>column with <code>City</code> - <code>race.city</code></li>
<li>column with <code>State</code> - <code>race.state</code></li>
<li>column with <code>Swim</code> - <code>race.swim_distance</code></li>
<li>column with <code>units</code> - <code>race.swim_units</code></li>
<li>column with <code>Bike</code> - <code>race.bike_distance</code></li>
<li>column with <code>units</code> - <code>race.bike_units</code></li>
<li>column with <code>Run</code> - <code>race.run_distance</code></li>
<li>column with <code>units</code> - <code>race.run_units</code></li>
</ul>
<p><strong>Hint</strong>: Remember you can get a criteria of <code>upcoming_available_to</code> races that can be extended with and <code>order_by</code> to have to soonest races ordered to the top of the page.</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># app/controllers/racers_controller.rb </span>
<span class="kw">def</span> edit
  <span class="ot">@races</span>=<span class="dt">Race</span>.upcoming_available_to(<span class="ot">@racer</span>).order_by(<span class="st">:date</span>.asc)
<span class="kw">end</span></code></pre>
<p><strong>Hint</strong>: The view is in <code>triresults/app/views/racers/_form.html.erb</code> and a test of whether we are in edit or create mode can be accomplished using <code>@racer.persisted?</code>.</p>
<pre class="sourceCode html"><code class="sourceCode html"># triresults/app/views/racers/_form.html.erb
<span class="er">&lt;</span>% if @racer.persisted? %&gt;
  <span class="kw">&lt;table&gt;</span>
    <span class="kw">&lt;thead&gt;</span>
      <span class="kw">&lt;tr&gt;</span>
        <span class="kw">&lt;th&gt;</span>Name<span class="kw">&lt;/th&gt;</span>
        <span class="kw">&lt;th&gt;</span>Date<span class="kw">&lt;/th&gt;</span>
        <span class="kw">&lt;th&gt;</span>City<span class="kw">&lt;/th&gt;</span>
      ...
        <span class="kw">&lt;th&gt;</span>Run distance<span class="kw">&lt;/th&gt;</span>
        <span class="kw">&lt;th&gt;</span>Run units<span class="kw">&lt;/th&gt;</span>
        <span class="kw">&lt;th</span><span class="ot"> colspan=</span><span class="st">&quot;3&quot;</span><span class="kw">&gt;&lt;/th&gt;</span>
      <span class="kw">&lt;/tr&gt;</span>
    <span class="kw">&lt;/thead&gt;</span>

    <span class="kw">&lt;tbody&gt;</span>
      <span class="er">&lt;</span>% @races.each do |race| %&gt;
        <span class="kw">&lt;tr&gt;</span>
          <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= race.name %&gt;<span class="kw">&lt;/td&gt;</span>
          <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= race.date %&gt;<span class="kw">&lt;/td&gt;</span>
          <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= race.city %&gt;<span class="kw">&lt;/td&gt;</span>
      ...
          <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= race.run_distance %&gt;<span class="kw">&lt;/td&gt;</span>
          <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= race.run_units %&gt;<span class="kw">&lt;/td&gt;</span>
        <span class="kw">&lt;/tr&gt;</span>
      <span class="er">&lt;</span>% end %&gt;
    <span class="kw">&lt;/tbody&gt;</span>
  <span class="kw">&lt;/table&gt;</span>
<span class="er">&lt;</span>% end %&gt;</code></pre>
<p>At this point you should be able to see available races when attempting to edit a racer.</p>
<div class="figure">
<img src="docs/rsz_edit_racer_available_races.png" alt="Available Races" /><p class="caption">Available Races</p>
</div>
<p><a href="docs/rsz_edit_racer_available_races.png">Available Races</a></p>
<pre class="shell"><code>$ rspec spec/web_resources_spec.rb -e rq05</code></pre></li>
</ol>
<h3 id="web-racerrace-registration">Web Racer/Race Registration</h3>
<p>In this section you will implement the ability to register a <code>Racer</code> for a <code>Race</code> from the <code>racers#edit</code> page. This will involve the creation of a nested <code>Entrant</code> resource that can perform the work and a link from the page to trigger the work. Registration will be a single click and we will not implement the cancellation of registrations as part of this assignment.</p>
<ol style="list-style-type: decimal">
<li><p>Add a nested <code>entries</code> resource below the <code>racers</code> resource within <code>config/routes.rb</code>. Restrict functionality at this point to a <code>POST</code> and map it to a <code>create_entry</code> action method within <code>racers</code> controller.</p>
<p><strong>Hint</strong>:</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="dt">Rails</span>.application.routes.draw <span class="kw">do</span>
  resources <span class="st">:racers</span> <span class="kw">do</span>
    post <span class="st">&quot;entries&quot;</span> =&gt; <span class="st">&quot;racers#create_entry&quot;</span>
  <span class="kw">end</span></code></pre>
<p>This should produce the following route within your application and we will use the action to create a new entry for the racer.</p>
<pre class="shell"><code>$ rake routes | grep entries
racer_entries POST   /racers/:racer_id/entries(.:format) racers#create_entry</code></pre>
<ul>
<li><code>racer_entry</code> is the helper method prefix for <code>racer_entry_path</code>, which we can use to reference this URI when calling it</li>
<li><code>:racer_id</code> is the <code>_id</code> of the racer we are referencing</li>
</ul>
<pre class="shell"><code>$ rspec spec/web_registration_spec.rb -e rq01</code></pre></li>
<li><p>Add a method to the <code>racers</code> controller called <code>create_entry</code> that:</p>
<ul>
<li>finds the <code>Racer</code> based on a <code>params[:racer_id]</code></li>
<li>finds the <code>Race</code> based on <code>params[:race_id]</code></li>
<li>uses the <code>Racer.create_entrant</code> class method to create an <code>Entrant</code></li>
<li>re-directs the <code>racer#show</code> page with a status of the registration passed in the flash <code>notice</code></li>
</ul>
<p><strong>Hint</strong>:</p>
<pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># triresults/app/controllers/racers_controller.rb</span>
  <span class="co"># POST /racers/1/entries?race_id=1</span>
  <span class="kw">def</span> create_entry
    <span class="ot">@racer</span>=<span class="dt">Racer</span>.find(params[<span class="st">:racer_id</span>]) 
    <span class="ot">@race</span>=<span class="dt">Race</span>.find(params[<span class="st">:race_id</span>]) 
    <span class="ot">@entrant</span>=<span class="ot">@race</span>.create_entrant <span class="ot">@racer</span>

    respond_to <span class="kw">do</span> |format|
      <span class="kw">if</span> <span class="ot">@entrant</span>.valid?
        format.html { redirect_to <span class="ot">@racer</span>, notice: <span class="st">&#39;Race entry was successfully created.&#39;</span> }
        format.json { render <span class="st">:show</span>, status: <span class="st">:created</span>, location: <span class="ot">@racer</span> }
      <span class="kw">else</span>
        format.html { redirect_to <span class="ot">@racer</span>, notice: <span class="st">&quot;Invalid registration </span><span class="ot">#{@entrant</span>.errors.messages<span class="ot">}</span><span class="st">&quot;</span> }
        format.json { render json: <span class="ot">@entrant</span>.errors, status: <span class="st">:unprocessable_entity</span> }
      <span class="kw">end</span>
    <span class="kw">end</span>
  <span class="kw">end</span></code></pre>
<pre class="shell"><code>$ rspec spec/web_registration_spec.rb -e rq02</code></pre></li>
<li><p>Add a <code>Register</code> link from the table of upcoming and available races on the <code>racers#edit</code> view page. This link must</p>
<ul>
<li>issue a <code>POST</code> to the <code>racer_entries_path</code></li>
<li>pass the <code>racer_id</code> and <code>race_id</code> parameters to the controller</li>
</ul>
<p><strong>Hint</strong>: You are just adding a link within your existing table rows and having it navigate to the new controller action to complete the registration.</p>
<pre class="sourceCode html"><code class="sourceCode html"># app/views/racers/_form.html.erb
<span class="er">&lt;</span>%= form_for(@racer) do |f| %&gt;
  ...
  <span class="kw">&lt;tbody&gt;</span>
    <span class="er">&lt;</span>% @races.each do |race| %&gt;
      <span class="kw">&lt;tr&gt;</span>
      ...
        <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= race.run_distance %&gt;<span class="kw">&lt;/td&gt;</span>
        <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= race.run_units %&gt;<span class="kw">&lt;/td&gt;</span>
        <span class="kw">&lt;td&gt;</span><span class="er">&lt;</span>%= link_to &#39;Register&#39;, racer_entries_path(@racer, :race_id=&gt;race.id), method: :post %&gt;<span class="kw">&lt;/td&gt;</span>
      <span class="kw">&lt;/tr&gt;</span>
    <span class="er">&lt;</span>% end %&gt;
  <span class="kw">&lt;/tbody&gt;</span>
<span class="kw">&lt;/table&gt;</span></code></pre>
<p>At this point one should be able to register any valid <code>Racer</code> with a <code>Race</code>. You can see the newly created race <code>Entry</code> added to the <code>Races</code> table on the <code>racers#show</code> page. You can see the newly created race <code>Entry</code> added to the <code>Results</code> table on the on the <code>races#show</code> page.</p>
<div class="figure">
<img src="docs/rsz_edit_racer_register_races.jpg" alt="Register Racer" /><p class="caption">Register Racer</p>
</div>
<p><a href="docs/rsz_edit_racer_register_races.jpg">Register Racer</a></p>
<pre class="shell"><code>$ rspec spec/web_registration_spec.rb -e rq03</code></pre></li>
</ol>
<h3 id="optionalnot-graded-deploy-to-heroku">(Optional/Not Graded) Deploy to Heroku</h3>
<p>After completing the assignment and submitting for grading, optionally deploy your application to Heroku using the base name of <code>triresults</code> followed by a unique five (5) digit number that you chose.</p>
<h3 id="optional-extensions">(Optional) Extensions</h3>
<p>After completing the assignment and submitting for grading, optionally</p>
<ul>
<li>change the ordering of races so that they are ordered from closest to furthest from the racer's residence.</li>
<li>locate the racer who has come the fartest to participate</li>
</ul>
<p>All the required data is in place in the sample data. You just need to add a geolocation index to the racer's residence and race's location coordinates.</p>
<h2 id="self-gradingfeedback">Self Grading/Feedback</h2>
<p>Some unit tests have been provided in the bootstrap files and provide examples of tests the grader will be evaluating for when you submit your solution. They must be run from the project root directory.</p>
<pre class="shell"><code>$ rspec (file)
...
(N) examples, 0 failures</code></pre>
<p>You can run as many specific tests you wish be adding <code>-e rq## -e rq##</code></p>
<pre class="shell"><code>$ rspec (file) -e rq01 -e rq02</code></pre>
<h2 id="submission">Submission</h2>
<p>Submit an .zip archive (other archive forms not currently supported) with your solution root directory as the top-level (e.g., your Gemfile and sibling files must be in the root of the archive and <em>not</em> in a sub-folder. The grader will replace the spec files with fresh copies and will perform a test with different query terms.</p>
<pre class="text"><code>|-- app
|   |-- assets
|   |-- controllers
|   |-- helpers
|   |-- mailers
|   |-- models
|   `-- views
|-- bin
|-- config
|-- config.ru
|-- db
|-- Gemfile
|-- Gemfile.lock
|-- lib
|-- log
|-- public
|-- Rakefile
|-- README.rdoc
|-- test
`-- vendor</code></pre>
<h4 id="last-updated-2016-01-30a">Last Updated: 2016-01-30a</h4>
